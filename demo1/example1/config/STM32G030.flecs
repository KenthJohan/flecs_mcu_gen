@color #AA99AF
xmcu {}
module xmcu
module STM32G030

struct Position {
  x = i32,4
  y = f32
}

struct Rectangle {
  a = Position
  b = Position
}

struct Room {
  a = Rectangle,3
  b = Rectangle
}


peripherals {
	@color #9b2316
	@brief Analog to Digital ConverteR
	Room
	ADC {
		ec.Peripheral : {0}
		ec.Size : {size : {0x400, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x40012400, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief ADC interrupt and status register
		ADC_ISR {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief ADC ready\nThis bit is set by hardware after the ADC has been enabled (ADEN=1) and when the ADC reaches a state where it is ready to accept conversion requests.\nIt is cleared by software writing 1 to it.
			ADRDY {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief End of sampling flag\nThis bit is set by hardware during the conversion, at the end of the sampling phase.It is cleared by software by programming it to '1'.
			EOSMP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief End of conversion flag\nThis bit is set by hardware at the end of each conversion of a channel when a new data result is available in the ADC_DR register. It is cleared by software writing 1 to it or by reading the ADC_DR register.
			EOC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief End of sequence flag\nThis bit is set by hardware at the end of the conversion of a sequence of channels selected by the CHSEL bits. It is cleared by software writing 1 to it.
			EOS {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief ADC overrun\nThis bit is set by hardware when an overrun occurs, meaning that a new conversion has complete while the EOC flag was already set. It is cleared by software writing 1 to it.
			OVR {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog 1 flag\nThis bit is set by hardware when the converted voltage crosses the values programmed in ADC_TR1 and ADC_HR1 registers. It is cleared by software by programming it to 1.
			AWD1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog 2 flag\nThis bit is set by hardware when the converted voltage crosses the values programmed in ADC_AWD2TR and ADC_AWD2TR registers. It is cleared by software programming it it.
			AWD2 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog 3 flag\nThis bit is set by hardware when the converted voltage crosses the values programmed in ADC_AWD3TR and ADC_AWD3TR registers. It is cleared by software by programming it to 1.
			AWD3 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief End Of Calibration flag\nThis bit is set by hardware when calibration is complete. It is cleared by software writing 1 to it.
			EOCAL {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel Configuration Ready flag\nThis flag bit is set by hardware when the channel configuration is applied after programming to ADC_CHSELR register or changing CHSELRMOD or SCANDIR. It is cleared by software by programming it to it.\nNote: When the softwa
			CCRDY {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief ADC interrupt enable register 
		ADC_IER {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x4, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief ADC ready interrupt enable\nThis bit is set and cleared by software to enable/disable the ADC Ready interrupt.\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
			ADRDYIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief End of sampling flag interrupt enable\nThis bit is set and cleared by software to enable/disable the end of the sampling phase interrupt.\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion
			EOSMPIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief End of conversion interrupt enable\nThis bit is set and cleared by software to enable/disable the end of conversion interrupt.\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing
			EOCIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief End of conversion sequence interrupt enable\nThis bit is set and cleared by software to enable/disable the end of sequence of conversions interrupt.\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no
			EOSIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Overrun interrupt enable\nThis bit is set and cleared by software to enable/disable the overrun interrupt.\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
			OVRIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog 1 interrupt enable\nThis bit is set and cleared by software to enable/disable the analog watchdog interrupt.\nNote: The Software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
			AWD1IE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog 2 interrupt enable\nThis bit is set and cleared by software to enable/disable the analog watchdog interrupt.\nNote: The Software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
			AWD2IE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog 3 interrupt enable\nThis bit is set and cleared by software to enable/disable the analog watchdog interrupt.\nNote: The Software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
			AWD3IE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief End of calibration interrupt enable\nThis bit is set and cleared by software to enable/disable the end of calibration interrupt.\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoi
			EOCALIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel Configuration Ready Interrupt enable\nThis bit is set and cleared by software to enable/disable the channel configuration ready interrupt.\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no c
			CCRDYIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief ADC control register
		ADC_CR {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x8, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief ADC enable command\nThis bit is set by software to enable the ADC. The ADC is effectively ready to operate once the ADRDY flag has been set.\nIt is cleared by hardware when the ADC is disabled, after the execution of the ADDIS command.\nNote: The software is
			ADEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief ADC disable command\nThis bit is set by software to disable the ADC (ADDIS command) and put it into power-down state (OFF state).\nIt is cleared by hardware once the ADC is effectively disabled (ADEN is also cleared by hardware at this time).\nNote: Setting 
			ADDIS {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief ADC start conversion command\nThis bit is set by software to start ADC conversion. Depending on the EXTEN [1:0] configuration bits, a conversion either starts immediately (software trigger configuration) or once a hardware trigger event occurs (hardware tr
			ADSTART {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief ADC stop conversion command\nThis bit is set by software to stop and discard an ongoing conversion (ADSTP Command).\nIt is cleared by hardware when the conversion is effectively discarded and the ADC is ready to accept a new start conversion command.\nNote: 
			ADSTP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief ADC Voltage Regulator Enable\nThis bit is set by software, to enable the ADC internal voltage regulator. The voltage regulator output is available after tADCVREG_SETUP.\nIt is cleared by software to disable the voltage regulator. It can be cleared only if A
			ADVREGEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief ADC calibration\nThis bit is set by software to start the calibration of the ADC.\nIt is cleared by hardware after calibration is complete.\nNote: The software is allowed to set ADCAL only when the ADC is disabled (ADCAL=0, ADSTART=0, ADSTP=0, ADDIS=0 and AD
			ADCAL {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {31, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief ADC configuration register 1
		ADC_CFGR1 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xc, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Direct memory access enable\nThis bit is set and cleared by software to enable the generation of DMA requests. This allows the DMA controller to be used to manage automatically the converted data. For more details, refer to .\nNote: The software is allowed 
			DMAEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Direct memory access configuration\nThis bit is set and cleared by software to select between two DMA modes of operation and is effective only when DMAEN=1.\nFor more details, refer to page351\nNote: The software is allowed to write this bit only when ADSTAR
			DMACFG {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Scan sequence direction\nThis bit is set and cleared by software to select the direction in which the channels is scanned in the sequence. It is effective only if CHSELMOD bit is cleared to 0.\nNote: The software is allowed to write this bit only when ADSTA
			SCANDIR {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Data resolution\nThese bits are written by software to select the resolution of the conversion.\nNote: The software is allowed to write these bits only when ADEN=0.
			RES {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Data alignment\nThis bit is set and cleared by software to select right or left alignment. Refer to Data alignment and resolution (oversampling disabled: OVSE = 0) on page349\nNote: The software is allowed to write this bit only when ADSTART bit is cleared 
			ALIGN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief External trigger selection\nThese bits select the external event used to trigger the start of conversion (refer to External triggers for details):\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no c
			EXTSEL {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief External trigger enable and polarity selection\nThese bits are set and cleared by software to select the external trigger polarity and enable the trigger.\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures t
			EXTEN {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Overrun management mode\nThis bit is set and cleared by software and configure the way data overruns are managed.\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
			OVRMOD {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Single / continuous conversion mode\nThis bit is set and cleared by software. If it is set, conversion takes place continuously until it is cleared.\nNote: It is not possible to have both discontinuous mode and continuous mode enabled: it is forbidden to se
			CONT {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Wait conversion mode\nThis bit is set and cleared by software to enable/disable wait conversion mode..\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
			WAIT {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Auto-off mode\nThis bit is set and cleared by software to enable/disable auto-off mode..\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
			AUTOFF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Discontinuous mode\nThis bit is set and cleared by software to enable/disable discontinuous mode.\nNote: It is not possible to have both discontinuous mode and continuous mode enabled: it is forbidden to set both bits DISCEN=1 and CONT=1.\nThe software is al
			DISCEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Mode selection of the ADC_CHSELR register\nThis bit is set and cleared by software to control the ADC_CHSELR feature:\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).\nIf CCR
			CHSELRMOD {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Enable the watchdog on a single channel or on all channels\nThis bit is set and cleared by software to enable the analog watchdog on the channel identified by the AWDCH[4:0] bits or on all the channels\nNote: The software is allowed to write this bit only w
			AWD1SGL {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog enable\nThis bit is set and cleared by software.\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
			AWD1EN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They select the input channel to be guarded by the analog watchdog.\n.....\nOthers: Reserved\nNote: The channel selected by the AWDCH[4:0] bits must be also set into the CHSELR reg
			AWD1CH {
				ec.Access : {R|W}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief ADC configuration register 2
		ADC_CFGR2 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Oversampler Enable\nThis bit is set and cleared by software.\nNote: Software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
			OVSE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Oversampling ratio\nThis bit filed defines the number of oversampling ratio.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
			OVSR {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Oversampling shift\nThis bit is set and cleared by software.\nOthers: Reserved\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
			OVSS {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Triggered Oversampling\nThis bit is set and cleared by software.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
			TOVS {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Low frequency trigger mode enable\nThis bit is set and cleared by software.\nNote: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
			LFTRIG {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {29, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief ADC clock mode\nThese bits are set and cleared by software to define how the analog ADC is clocked:\nIn all synchronous clock modes, there is no jitter in the delay from a timer trigger to the start of a conversion.\nNote: The software is allowed to write th
			CKMODE {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief ADC sampling time register
		ADC_SMPR {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x14, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Sampling time selection 1\nThese bits are written by software to select the sampling time that applies to all channels.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
			SMP1 {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Sampling time selection 2\nThese bits are written by software to select the sampling time that applies to all channels.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
			SMP2 {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x sampling time selection\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
			SMPSEL0 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x sampling time selection\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
			SMPSEL1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x sampling time selection\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
			SMPSEL2 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x sampling time selection\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
			SMPSEL3 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x sampling time selection\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
			SMPSEL4 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x sampling time selection\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
			SMPSEL5 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x sampling time selection\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
			SMPSEL6 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x sampling time selection\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
			SMPSEL7 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x sampling time selection\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
			SMPSEL8 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x sampling time selection\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
			SMPSEL9 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x sampling time selection\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
			SMPSEL10 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x sampling time selection\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
			SMPSEL11 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x sampling time selection\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
			SMPSEL12 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x sampling time selection\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
			SMPSEL13 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x sampling time selection\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
			SMPSEL14 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x sampling time selection\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
			SMPSEL15 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x sampling time selection\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
			SMPSEL16 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x sampling time selection\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
			SMPSEL17 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {25, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x sampling time selection\nThese bits are written by software to define which sampling time is used.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
			SMPSEL18 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief ADC watchdog threshold register
		ADC_AWD1TR {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x20, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Analog watchdog 1 lower threshold\nThese bits are written by software to define the lower threshold for the analog watchdog.\nRefer to ADC_AWDxTR) on page355.
			LT1 {
				ec.Access : {R|W}
				ec.Size : {size : {12, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog 1 higher threshold\nThese bits are written by software to define the higher threshold for the analog watchdog.\nRefer to ADC_AWDxTR) on page355.
			HT1 {
				ec.Access : {R|W}
				ec.Size : {size : {12, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief ADC watchdog threshold register
		ADC_AWD2TR {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x24, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Analog watchdog 2 lower threshold\nThese bits are written by software to define the lower threshold for the analog watchdog.\nRefer to ADC_AWDxTR) on page355.
			LT2 {
				ec.Access : {R|W}
				ec.Size : {size : {12, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog 2 higher threshold\nThese bits are written by software to define the higher threshold for the analog watchdog.\nRefer to ADC_AWDxTR) on page355.
			HT2 {
				ec.Access : {R|W}
				ec.Size : {size : {12, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief ADC channel selection register [alternate] 
		ADC_CHSELR_0 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x28, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to  for ADC inputs connected to external channels and internal sources.\nNote: The software is allowed to write thi
			CHSEL0 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to  for ADC inputs connected to external channels and internal sources.\nNote: The software is allowed to write thi
			CHSEL1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to  for ADC inputs connected to external channels and internal sources.\nNote: The software is allowed to write thi
			CHSEL2 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to  for ADC inputs connected to external channels and internal sources.\nNote: The software is allowed to write thi
			CHSEL3 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to  for ADC inputs connected to external channels and internal sources.\nNote: The software is allowed to write thi
			CHSEL4 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to  for ADC inputs connected to external channels and internal sources.\nNote: The software is allowed to write thi
			CHSEL5 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to  for ADC inputs connected to external channels and internal sources.\nNote: The software is allowed to write thi
			CHSEL6 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to  for ADC inputs connected to external channels and internal sources.\nNote: The software is allowed to write thi
			CHSEL7 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to  for ADC inputs connected to external channels and internal sources.\nNote: The software is allowed to write thi
			CHSEL8 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to  for ADC inputs connected to external channels and internal sources.\nNote: The software is allowed to write thi
			CHSEL9 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to  for ADC inputs connected to external channels and internal sources.\nNote: The software is allowed to write thi
			CHSEL10 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to  for ADC inputs connected to external channels and internal sources.\nNote: The software is allowed to write thi
			CHSEL11 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to  for ADC inputs connected to external channels and internal sources.\nNote: The software is allowed to write thi
			CHSEL12 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to  for ADC inputs connected to external channels and internal sources.\nNote: The software is allowed to write thi
			CHSEL13 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to  for ADC inputs connected to external channels and internal sources.\nNote: The software is allowed to write thi
			CHSEL14 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to  for ADC inputs connected to external channels and internal sources.\nNote: The software is allowed to write thi
			CHSEL15 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to  for ADC inputs connected to external channels and internal sources.\nNote: The software is allowed to write thi
			CHSEL16 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to  for ADC inputs connected to external channels and internal sources.\nNote: The software is allowed to write thi
			CHSEL17 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel-x selection\nThese bits are written by software and define which channels are part of the sequence of channels to be converted. Refer to  for ADC inputs connected to external channels and internal sources.\nNote: The software is allowed to write thi
			CHSEL18 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief channel selection register CHSELRMOD = 1 in\n            ADC_CFGR1
		ADC_CHSELR_1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x28, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief 1st conversion of the sequence\nThese bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence.\nWhen 0b1111 (end of sequence) is programmed to the lower sequence c
			SQ1 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief 2nd conversion of the sequence\nThese bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence.\nWhen 0b1111 (end of sequence) is programmed to the lower sequence c
			SQ2 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief 3rd conversion of the sequence\nThese bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence.\nWhen 0b1111 (end of sequence) is programmed to the lower sequence c
			SQ3 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief 4th conversion of the sequence\nThese bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence.\nWhen 0b1111 (end of sequence) is programmed to the lower sequence c
			SQ4 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief 5th conversion of the sequence\nThese bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence.\nWhen 0b1111 (end of sequence) is programmed to the lower sequence c
			SQ5 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief 6th conversion of the sequence\nThese bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence.\nWhen 0b1111 (end of sequence) is programmed to the lower sequence c
			SQ6 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief 7th conversion of the sequence\nThese bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates end of the sequence.\nWhen 0b1111 (end of sequence) is programmed to the lower sequence c
			SQ7 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief 8th conversion of the sequence\nThese bits are programmed by software with the channel number (0...14) assigned to the 8th conversion of the sequence. 0b1111 indicates the end of the sequence.\nWhen 0b1111 (end of sequence) is programmed to the lower sequen
			SQ8 {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief ADC watchdog threshold register
		ADC_AWD3TR {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x2c, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Analog watchdog 3lower threshold\nThese bits are written by software to define the lower threshold for the analog watchdog.\nRefer to ADC_AWDxTR) on page355.
			LT3 {
				ec.Access : {R|W}
				ec.Size : {size : {12, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog 3 higher threshold\nThese bits are written by software to define the higher threshold for the analog watchdog.\nRefer to ADC_AWDxTR) on page355.
			HT3 {
				ec.Access : {R|W}
				ec.Size : {size : {12, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief ADC data register
		ADC_DR {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x40, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Converted data\nThese bits are read-only. They contain the conversion result from the last converted channel. The data are left- or right-aligned as shown in OVSE = 0) on page349.\nJust after a calibration is complete, DATA[6:0] contains the calibration fac
			DATA {
				ec.Access : {R}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief ADC Analog Watchdog 2 Configuration register
		ADC_AWD2CR {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xa0, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR r
			AWD2CH0 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR r
			AWD2CH1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR r
			AWD2CH2 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR r
			AWD2CH3 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR r
			AWD2CH4 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR r
			AWD2CH5 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR r
			AWD2CH6 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR r
			AWD2CH7 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR r
			AWD2CH8 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR r
			AWD2CH9 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR r
			AWD2CH10 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR r
			AWD2CH11 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR r
			AWD2CH12 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR r
			AWD2CH13 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR r
			AWD2CH14 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR r
			AWD2CH15 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR r
			AWD2CH16 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR r
			AWD2CH17 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 2 (AWD2).\nNote: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR r
			AWD2CH18 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief ADC Analog Watchdog 3 Configuration register
		ADC_AWD3CR {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xa4, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR r
			AWD3CH0 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR r
			AWD3CH1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR r
			AWD3CH2 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR r
			AWD3CH3 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR r
			AWD3CH4 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR r
			AWD3CH5 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR r
			AWD3CH6 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR r
			AWD3CH7 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR r
			AWD3CH8 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR r
			AWD3CH9 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR r
			AWD3CH10 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR r
			AWD3CH11 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR r
			AWD3CH12 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR r
			AWD3CH13 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR r
			AWD3CH14 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR r
			AWD3CH15 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR r
			AWD3CH16 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR r
			AWD3CH17 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog watchdog channel selection\nThese bits are set and cleared by software. They enable and select the input channels to be guarded by analog watchdog 3 (AWD3).\nNote: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR r
			AWD3CH18 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief ADC Calibration factor
		ADC_CALFACT {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xb4, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Calibration factor\nThese bits are written by hardware or by software.\nOnce a calibration is complete,they are updated by hardware with the calibration factors.\nSoftware can write these bits with a new calibration factor. If the new calibration factor is d
			CALFACT {
				ec.Access : {R|W}
				ec.Size : {size : {7, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief ADC common configuration register
		ADC_CCR {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x308, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief ADC prescaler\nSet and cleared by software to select the frequency of the clock to the ADC.\nOther: Reserved\nNote: Software is allowed to write these bits only when the ADC is disabled (ADCAL=0, ADSTART=0, ADSTP=0, ADDIS=0 and ADEN=0).
			PRESC {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief VREFINT enable\nThis bit is set and cleared by software to enable/disable the VREFINT.\nNote: Software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
			VREFEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Temperature sensor enable\nThis bit is set and cleared by software to enable/disable the temperature sensor.\nNote: Software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
			TSEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief VBAT enable\nThis bit is set and cleared by software to enable/disable the VBAT channel.\nNote: The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing)
			VBATEN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief Independent watchdog
	IWDG {
		ec.Peripheral : {0}
		ec.Size : {size : {0x400, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x40003000, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief Key register
		KR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Key value (write only, read\n              0x0000)
			KEY {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Prescaler register
		PR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x4, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Prescaler divider
			PR {
				ec.Access : {0}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Reload register
		RLR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x8, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Watchdog counter reload\n              value
			RL {
				ec.Access : {0}
				ec.Size : {size : {12, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Status register
		SR {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xC, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Watchdog counter window value\n              update
			WVU {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Watchdog counter reload value\n              update
			RVU {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Watchdog prescaler value\n              update
			PVU {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Window register
		WINR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Watchdog counter window\n              value
			WIN {
				ec.Access : {0}
				ec.Size : {size : {12, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief System window watchdog
	WWDG {
		ec.Peripheral : {0}
		ec.Size : {size : {0x400, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x40002C00, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief Control register
		CR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Activation bit
			WDGA {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief 7-bit counter (MSB to LSB)
			T {
				ec.Access : {0}
				ec.Size : {size : {7, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Configuration register
		CFR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x4, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Timer base
			WDGTB {
				ec.Access : {0}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Early wakeup interrupt
			EWI {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief 7-bit window value
			W {
				ec.Access : {0}
				ec.Size : {size : {7, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Status register
		SR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x8, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Early wakeup interrupt\n              flag
			EWIF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief Flash
	FLASH {
		ec.Peripheral : {0}
		ec.Size : {size : {0x400, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x40022000, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief Access control register
		ACR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Latency
			LATENCY {
				ec.Access : {0}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Prefetch enable
			PRFTEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Instruction cache enable
			ICEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Instruction cache reset
			ICRST {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Flash User area empty
			EMPTY {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Flash key register
		KEYR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x8, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief KEYR
			KEYR {
				ec.Access : {0}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Option byte key register
		OPTKEYR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xC, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Option byte key
			OPTKEYR {
				ec.Access : {0}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Status register
		SR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief End of operation
			EOP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Operation error
			OPERR {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Programming error
			PROGERR {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Write protected error
			WRPERR {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Programming alignment\n              error
			PGAERR {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Size error
			SIZERR {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Programming sequence error
			PGSERR {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Fast programming data miss\n              error
			MISERR {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Fast programming error
			FASTERR {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Option and Engineering bits loading\n              validity error
			OPTVERR {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief BSY1
			BSY1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief BSY2
			BSY2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Programming or erase configuration\n              busy.
			CFGBSY {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Flash control register
		CR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x14, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Programming
			PG {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Page erase
			PER {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Mass erase
			MER1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Page number
			PNB {
				ec.Access : {0}
				ec.Size : {size : {10, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief BKER
			BKER {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief MER2
			MER2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Start
			STRT {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Options modification start
			OPTSTRT {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Fast programming
			FSTPG {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief End of operation interrupt\n              enable
			EOPIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Error interrupt enable
			ERRIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {25, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Force the option byte\n              loading
			OBL_LAUNCH {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {27, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Options Lock
			OPTLOCK {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief FLASH_CR Lock
			LOCK {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {31, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Flash ECC register
		ECCR {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief ECC fail address
			ADDR_ECC {
				ec.Access : {R}
				ec.Size : {size : {14, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief ECC fail for Corrected ECC Error or\n              Double ECC Error in info block
			SYSF_ECC {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief ECC correction interrupt\n              enable
			ECCIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief ECC correction
			ECCC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief ECC detection
			ECCD {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {31, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Flash option register
		OPTR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x20, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Read protection level
			RDP {
				ec.Access : {0}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief nRST_STOP
			nRST_STOP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief nRST_STDBY
			nRST_STDBY {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Independent watchdog\n              selection
			IDWG_SW {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Independent watchdog counter freeze in\n              Stop mode
			IWDG_STOP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Independent watchdog counter freeze in\n              Standby mode
			IWDG_STDBY {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Window watchdog selection
			WWDG_SW {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief nSWAP_BANK
			nSWAP_BANK {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DUAL_BANK
			DUAL_BANK {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SRAM parity check control
			RAM_PARITY_CHECK {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief nBOOT_SEL
			nBOOT_SEL {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Boot configuration
			nBOOT1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {25, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief nBOOT0 option bit
			nBOOT0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Flash WRP area A address\n          register
		WRP1AR {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x2C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief WRP area A start offset
			WRP1A_STRT {
				ec.Access : {0}
				ec.Size : {size : {7, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief WRP area A end offset
			WRP1A_END {
				ec.Access : {0}
				ec.Size : {size : {7, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Flash WRP area B address\n          register
		WRP1BR {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x30, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief WRP area B start offset
			WRP1B_STRT {
				ec.Access : {0}
				ec.Size : {size : {7, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief WRP area B end offset
			WRP1B_END {
				ec.Access : {0}
				ec.Size : {size : {7, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief FLASH WRP2 area A address register
		WRP2AR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x4C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief WRP2A_STRT
			WRP2A_STRT {
				ec.Access : {0}
				ec.Size : {size : {7, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief WRP2A_END
			WRP2A_END {
				ec.Access : {0}
				ec.Size : {size : {7, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief FLASH WRP2 area B address register
		WRP2BR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x50, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief WRP2B_STRT
			WRP2B_STRT {
				ec.Access : {0}
				ec.Size : {size : {7, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief WRP2B_END
			WRP2B_END {
				ec.Access : {0}
				ec.Size : {size : {7, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief Reset and clock control
	RCC {
		ec.Peripheral : {0}
		ec.Size : {size : {0x400, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x40021000, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief Clock control register
		CR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief HSI16 clock enable
			HSION {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief HSI16 always enable for peripheral\n              kernels
			HSIKERON {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief HSI16 clock ready flag
			HSIRDY {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief HSI16 clock division\n              factor
			HSIDIV {
				ec.Access : {0}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief HSE clock enable
			HSEON {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief HSE clock ready flag
			HSERDY {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief HSE crystal oscillator\n              bypass
			HSEBYP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clock security system\n              enable
			CSSON {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief PLL enable
			PLLON {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief PLL clock ready flag
			PLLRDY {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {25, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Internal clock sources calibration\n          register
		ICSCR {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x4, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief HSI16 clock calibration
			HSICAL {
				ec.Access : {R}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief HSI16 clock trimming
			HSITRIM {
				ec.Access : {R|W}
				ec.Size : {size : {7, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Clock configuration register
		CFGR {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x8, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Microcontroller clock output\n              prescaler
			MCOPRE {
				ec.Access : {R}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Microcontroller clock\n              output
			MCOSEL {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief MCO2PRE
			MCO2PRE {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief MCO2SEL
			MCO2SEL {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief APB prescaler
			PPRE {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief AHB prescaler
			HPRE {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief System clock switch status
			SWS {
				ec.Access : {R}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief System clock switch
			SW {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief PLL configuration register
		PLLSYSCFGR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xC, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief PLL input clock source
			PLLSRC {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Division factor M of the PLL input clock\n              divider
			PLLM {
				ec.Access : {0}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief PLL frequency multiplication factor\n              N
			PLLN {
				ec.Access : {0}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief PLLPCLK clock output\n              enable
			PLLPEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief PLL VCO division factor P for PLLPCLK\n              clock output
			PLLP {
				ec.Access : {0}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief PLLQCLK clock output\n              enable
			PLLQEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief PLL VCO division factor Q for PLLQCLK\n              clock output
			PLLQ {
				ec.Access : {0}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {25, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief PLLRCLK clock output\n              enable
			PLLREN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief PLL VCO division factor R for PLLRCLK\n              clock output
			PLLR {
				ec.Access : {0}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {29, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Clock interrupt enable\n          register
		CIER {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief LSI ready interrupt enable
			LSIRDYIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief LSE ready interrupt enable
			LSERDYIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief HSI ready interrupt enable
			HSIRDYIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief HSE ready interrupt enable
			HSERDYIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief PLL ready interrupt enable
			PLLSYSRDYIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Clock interrupt flag register
		CIFR {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x1C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief LSI ready interrupt flag
			LSIRDYF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief LSE ready interrupt flag
			LSERDYF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief HSI ready interrupt flag
			HSIRDYF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief HSE ready interrupt flag
			HSERDYF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief PLL ready interrupt flag
			PLLSYSRDYF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clock security system interrupt\n              flag
			CSSF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief LSE Clock security system interrupt\n              flag
			LSECSSF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Clock interrupt clear register
		CICR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x20, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief LSI ready interrupt clear
			LSIRDYC {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief LSE ready interrupt clear
			LSERDYC {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief HSI ready interrupt clear
			HSIRDYC {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief HSE ready interrupt clear
			HSERDYC {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief PLL ready interrupt clear
			PLLSYSRDYC {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clock security system interrupt\n              clear
			CSSC {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief LSE Clock security system interrupt\n              clear
			LSECSSC {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief I/O port reset register
		IOPRSTR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x24, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief GPIOARST
			GPIOARST {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief GPIOBRST
			GPIOBRST {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief GPIOCRST
			GPIOCRST {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief GPIODRST
			GPIODRST {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief GPIOERST
			GPIOERST {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief GPIOFRST
			GPIOFRST {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief AHB peripheral reset register
		AHBRSTR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x28, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief DMA1 reset
			DMA1RST {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA1 reset
			DMA2RST {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief FLITF reset
			FLASHRST {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CRC reset
			CRCRST {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief APB peripheral reset register\n          1
		APBRSTR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x2C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief TIM3 timer reset
			TIM3RST {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TIM4 timer reset
			TIM4RST {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TIM6 timer reset
			TIM6RST {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TIM7 timer reset
			TIM7RST {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief USART5RST
			USART5RST {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief USART6RST
			USART6RST {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief USBRST
			USBRST {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SPI2 reset
			SPI2RST {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SPI3 reset
			SPI3RST {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief USART2 reset
			USART2RST {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief USART3 reset
			USART3RST {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief USART4 reset
			USART4RST {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I2C1 reset
			I2C1RST {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I2C2 reset
			I2C2RST {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I2C3RST reset
			I2C3RST {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Debug support reset
			DBGRST {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {27, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Power interface reset
			PWRRST {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief APB peripheral reset register\n          2
		APBRSTR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x30, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief SYSCFG, COMP and VREFBUF\n              reset
			SYSCFGRST {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TIM1 timer reset
			TIM1RST {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SPI1 reset
			SPI1RST {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief USART1 reset
			USART1RST {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TIM14 timer reset
			TIM14RST {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TIM15 timer reset
			TIM15RST {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TIM16 timer reset
			TIM16RST {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TIM17 timer reset
			TIM17RST {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief ADC reset
			ADCRST {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO clock enable register
		IOPENR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x34, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief I/O port A clock enable during Sleep\n              mode
			GPIOAEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I/O port B clock enable during Sleep\n              mode
			GPIOBEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I/O port C clock enable during Sleep\n              mode
			GPIOCEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I/O port D clock enable during Sleep\n              mode
			GPIODEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I/O port E clock enable during Sleep\n              mode
			GPIOEEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I/O port F clock enable during Sleep\n              mode
			GPIOFEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief AHB peripheral clock enable\n          register
		AHBENR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x38, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief DMA1 clock enable
			DMA1EN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA2 clock enable
			DMA2EN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Flash memory interface clock\n              enable
			FLASHEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CRC clock enable
			CRCEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief APB peripheral clock enable register\n          1
		APBENR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x3C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief TIM3 timer clock enable
			TIM3EN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TIM4 timer clock enable
			TIM4EN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TIM6 timer clock enable
			TIM6EN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TIM7 timer clock enable
			TIM7EN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief USART5EN
			USART5EN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief USART6EN
			USART6EN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RTC APB clock enable
			RTCAPBEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief WWDG clock enable
			WWDGEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief USBEN
			USBEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SPI2 clock enable
			SPI2EN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SPI3 clock enable
			SPI3EN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief USART2 clock enable
			USART2EN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief USART3 clock enable
			USART3EN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief USART4 clock enable
			USART4EN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I2C1 clock enable
			I2C1EN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I2C2 clock enable
			I2C2EN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I2C3 clock enable
			I2C3EN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Debug support clock enable
			DBGEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {27, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Power interface clock\n              enable
			PWREN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief APB peripheral clock enable register\n          2
		APBENR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x40, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief SYSCFG, COMP and VREFBUF clock\n              enable
			SYSCFGEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TIM1 timer clock enable
			TIM1EN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SPI1 clock enable
			SPI1EN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief USART1 clock enable
			USART1EN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TIM14 timer clock enable
			TIM14EN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TIM15 timer clock enable
			TIM15EN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TIM16 timer clock enable
			TIM16EN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TIM16 timer clock enable
			TIM17EN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief ADC clock enable
			ADCEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO in Sleep mode clock enable\n          register
		IOPSMENR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x44, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief I/O port A clock enable during Sleep\n              mode
			GPIOASMEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I/O port B clock enable during Sleep\n              mode
			GPIOBSMEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I/O port C clock enable during Sleep\n              mode
			GPIOCSMEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I/O port D clock enable during Sleep\n              mode
			GPIODSMEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I/O port E clock enable during Sleep\n              mode
			GPIOESMEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I/O port F clock enable during Sleep\n              mode
			GPIOFSMEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief AHB peripheral clock enable in Sleep mode\n          register
		AHBSMENR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x48, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief DMA1 clock enable during Sleep\n              mode
			DMA1SMEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA2 clock enable during Sleep\n              mode
			DMA2SMEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Flash memory interface clock enable\n              during Sleep mode
			FLASHSMEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SRAM clock enable during Sleep\n              mode
			SRAMSMEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CRC clock enable during Sleep\n              mode
			CRCSMEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief APB peripheral clock enable in Sleep mode\n          register 1
		APBSMENR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x4C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief TIM3 timer clock enable during Sleep\n              mode
			TIM3SMEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TIM4 timer clock enable during Sleep\n              mode
			TIM4SMEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TIM6 timer clock enable during Sleep\n              mode
			TIM6SMEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TIM7 timer clock enable during Sleep\n              mode
			TIM7SMEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief USART5 clock enable
			USART5SMEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief USART6 clock enable
			USART6SMEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RTC APB clock enable during Sleep\n              mode
			RTCAPBSMEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief WWDG clock enable during Sleep\n              mode
			WWDGSMEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief USB clock enable during Sleep\n              mode
			USBSMEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SPI2 clock enable during Sleep\n              mode
			SPI2SMEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SPI3 clock enable during Sleep\n              mode
			SPI3SMEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief USART2 clock enable during Sleep\n              mode
			USART2SMEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief USART3 clock enable during Sleep\n              mode
			USART3SMEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief USART4 clock enable during Sleep\n              mode
			USART4SMEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I2C1 clock enable during Sleep\n              mode
			I2C1SMEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I2C2 clock enable during Sleep\n              mode
			I2C2SMEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I2C3 clock enable during Sleep\n              mode
			I2C3SMEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Debug support clock enable during Sleep\n              mode
			DBGSMEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {27, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Power interface clock enable during\n              Sleep mode
			PWRSMEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief APB peripheral clock enable in Sleep mode\n          register 2
		APBSMENR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x50, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief SYSCFG, COMP and VREFBUF clock enable\n              during Sleep mode
			SYSCFGSMEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TIM1 timer clock enable during Sleep\n              mode
			TIM1SMEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SPI1 clock enable during Sleep\n              mode
			SPI1SMEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief USART1 clock enable during Sleep\n              mode
			USART1SMEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TIM14 timer clock enable during Sleep\n              mode
			TIM14SMEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TIM15 timer clock enable during Sleep\n              mode
			TIM15SMEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TIM16 timer clock enable during Sleep\n              mode
			TIM16SMEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TIM16 timer clock enable during Sleep\n              mode
			TIM17SMEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief ADC clock enable during Sleep\n              mode
			ADCSMEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Peripherals independent clock configuration\n          register
		CCIPR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x54, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief USART1 clock source\n              selection
			USART1SEL {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief USART2 clock source\n              selection
			USART2SEL {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief USART3 clock source\n              selection
			USART3SEL {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I2C1 clock source\n              selection
			I2C1SEL {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I2S1 clock source\n              selection
			I2S2SEL {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TIM1 clock source\n              selection
			TIM1SEL {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TIM15 clock source\n              selection
			TIM15SEL {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief ADCs clock source\n              selection
			ADCSEL {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Peripherals independent clock configuration register 2
		CCIPR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x58, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief 2S1SEL
			I2S1SEL {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I2S2SEL
			I2S2SEL {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief USBSEL
			USBSEL {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RTC domain control register
		BDCR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x5C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief LSE oscillator enable
			LSEON {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief LSE oscillator ready
			LSERDY {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief LSE oscillator bypass
			LSEBYP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief LSE oscillator drive\n              capability
			LSEDRV {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CSS on LSE enable
			LSECSSON {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CSS on LSE failure\n              Detection
			LSECSSD {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RTC clock source selection
			RTCSEL {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RTC clock enable
			RTCEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RTC domain software reset
			BDRST {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Low-speed clock output (LSCO)\n              enable
			LSCOEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Low-speed clock output\n              selection
			LSCOSEL {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {25, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Control/status register
		CSR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x60, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief LSI oscillator enable
			LSION {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief LSI oscillator ready
			LSIRDY {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Remove reset flags
			RMVF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Option byte loader reset\n              flag
			OBLRSTF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {25, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Pin reset flag
			PINRSTF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief BOR or POR/PDR flag
			PWRRSTF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {27, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Software reset flag
			SFTRSTF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Independent window watchdog reset\n              flag
			IWDGRSTF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {29, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Window watchdog reset flag
			WWDGRSTF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Low-power reset flag
			LPWRRSTF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {31, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief Power control
	PWR {
		ec.Peripheral : {0}
		ec.Size : {size : {0x400, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x40007000, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief Power control register 1
		CR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Low-power run
			LPR {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Voltage scaling range\n              selection
			VOS {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Disable backup domain write\n              protection
			DBP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Flash memory powered down during\n              Low-power sleep mode
			FPD_LPSLP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Flash memory powered down during\n              Low-power run mode
			FPD_LPRUN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Flash memory powered down during Stop\n              mode
			FPD_STOP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Low-power mode selection
			LPMS {
				ec.Access : {0}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Power control register 2
		CR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x4, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief USV
			USV {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Power control register 3
		CR3 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x8, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Enable Wakeup pin WKUP1
			EWUP1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Enable Wakeup pin WKUP2
			EWUP2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Enable Wakeup pin WKUP3
			EWUP3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Enable Wakeup pin WKUP4
			EWUP4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Enable WKUP5 wakeup pin
			EWUP5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Enable WKUP6 wakeup pin
			EWUP6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Apply pull-up and pull-down\n              configuration
			APC {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Enable internal wakeup\n              line
			EIWUL {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Power control register 4
		CR4 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xC, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Wakeup pin WKUP1 polarity
			WP1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Wakeup pin WKUP2 polarity
			WP2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Wakeup pin WKUP3 polarity
			WP3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Wakeup pin WKUP4 polarity
			WP4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Wakeup pin WKUP5 polarity
			WP5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief WKUP6 wakeup pin polarity
			WP6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief VBAT battery charging\n              enable
			VBE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief VBAT battery charging resistor\n              selection
			VBRS {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Power status register 1
		SR1 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Wakeup flag 1
			WUF1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Wakeup flag 2
			WUF2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Wakeup flag 3
			WUF3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Wakeup flag 4
			WUF4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Wakeup flag 5
			WUF5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Wakeup flag 6
			WUF6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Standby flag
			SBF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Wakeup flag internal
			WUFI {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Power status register 2
		SR2 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x14, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Voltage scaling flag
			VOSF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Low-power regulator flag
			REGLPF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Low-power regulator\n              started
			REGLPS {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Flash ready flag
			FLASH_RDY {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Power status clear register
		SCR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Clear standby flag
			CSBF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clear wakeup flag 6
			CWUF6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clear wakeup flag 5
			CWUF5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clear wakeup flag 4
			CWUF4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clear wakeup flag 3
			CWUF3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clear wakeup flag 2
			CWUF2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clear wakeup flag 1
			CWUF1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Power Port A pull-up control\n          register
		PUCRA {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x20, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port A pull-up bit y\n              (y=0..15)
			PU15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-up bit y\n              (y=0..15)
			PU14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-up bit y\n              (y=0..15)
			PU13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-up bit y\n              (y=0..15)
			PU12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-up bit y\n              (y=0..15)
			PU11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-up bit y\n              (y=0..15)
			PU10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-up bit y\n              (y=0..15)
			PU9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-up bit y\n              (y=0..15)
			PU8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-up bit y\n              (y=0..15)
			PU7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-up bit y\n              (y=0..15)
			PU6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-up bit y\n              (y=0..15)
			PU5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-up bit y\n              (y=0..15)
			PU4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-up bit y\n              (y=0..15)
			PU3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-up bit y\n              (y=0..15)
			PU2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-up bit y\n              (y=0..15)
			PU1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-up bit y\n              (y=0..15)
			PU0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Power Port A pull-down control\n          register
		PDCRA {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x24, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port A pull-down bit y\n              (y=0..15)
			PD15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-down bit y\n              (y=0..15)
			PD14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-down bit y\n              (y=0..15)
			PD13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-down bit y\n              (y=0..15)
			PD12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-down bit y\n              (y=0..15)
			PD11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-down bit y\n              (y=0..15)
			PD10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-down bit y\n              (y=0..15)
			PD9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-down bit y\n              (y=0..15)
			PD8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-down bit y\n              (y=0..15)
			PD7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-down bit y\n              (y=0..15)
			PD6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-down bit y\n              (y=0..15)
			PD5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-down bit y\n              (y=0..15)
			PD4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-down bit y\n              (y=0..15)
			PD3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-down bit y\n              (y=0..15)
			PD2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-down bit y\n              (y=0..15)
			PD1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port A pull-down bit y\n              (y=0..15)
			PD0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Power Port B pull-up control\n          register
		PUCRB {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x28, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port B pull-up bit y\n              (y=0..15)
			PU15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-up bit y\n              (y=0..15)
			PU14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-up bit y\n              (y=0..15)
			PU13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-up bit y\n              (y=0..15)
			PU12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-up bit y\n              (y=0..15)
			PU11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-up bit y\n              (y=0..15)
			PU10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-up bit y\n              (y=0..15)
			PU9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-up bit y\n              (y=0..15)
			PU8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-up bit y\n              (y=0..15)
			PU7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-up bit y\n              (y=0..15)
			PU6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-up bit y\n              (y=0..15)
			PU5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-up bit y\n              (y=0..15)
			PU4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-up bit y\n              (y=0..15)
			PU3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-up bit y\n              (y=0..15)
			PU2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-up bit y\n              (y=0..15)
			PU1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-up bit y\n              (y=0..15)
			PU0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Power Port B pull-down control\n          register
		PDCRB {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x2C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port B pull-down bit y\n              (y=0..15)
			PD15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-down bit y\n              (y=0..15)
			PD14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-down bit y\n              (y=0..15)
			PD13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-down bit y\n              (y=0..15)
			PD12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-down bit y\n              (y=0..15)
			PD11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-down bit y\n              (y=0..15)
			PD10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-down bit y\n              (y=0..15)
			PD9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-down bit y\n              (y=0..15)
			PD8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-down bit y\n              (y=0..15)
			PD7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-down bit y\n              (y=0..15)
			PD6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-down bit y\n              (y=0..15)
			PD5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-down bit y\n              (y=0..15)
			PD4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-down bit y\n              (y=0..15)
			PD3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-down bit y\n              (y=0..15)
			PD2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-down bit y\n              (y=0..15)
			PD1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port B pull-down bit y\n              (y=0..15)
			PD0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Power Port C pull-up control\n          register
		PUCRC {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x30, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port C pull-up bit y\n              (y=0..15)
			PU15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-up bit y\n              (y=0..15)
			PU14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-up bit y\n              (y=0..15)
			PU13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-up bit y\n              (y=0..15)
			PU12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-up bit y\n              (y=0..15)
			PU11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-up bit y\n              (y=0..15)
			PU10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-up bit y\n              (y=0..15)
			PU9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-up bit y\n              (y=0..15)
			PU8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-up bit y\n              (y=0..15)
			PU7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-up bit y\n              (y=0..15)
			PU6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-up bit y\n              (y=0..15)
			PU5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-up bit y\n              (y=0..15)
			PU4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-up bit y\n              (y=0..15)
			PU3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-up bit y\n              (y=0..15)
			PU2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-up bit y\n              (y=0..15)
			PU1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-up bit y\n              (y=0..15)
			PU0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Power Port C pull-down control\n          register
		PDCRC {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x34, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port C pull-down bit y\n              (y=0..15)
			PD15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-down bit y\n              (y=0..15)
			PD14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-down bit y\n              (y=0..15)
			PD13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-down bit y\n              (y=0..15)
			PD12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-down bit y\n              (y=0..15)
			PD11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-down bit y\n              (y=0..15)
			PD10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-down bit y\n              (y=0..15)
			PD9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-down bit y\n              (y=0..15)
			PD8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-down bit y\n              (y=0..15)
			PD7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-down bit y\n              (y=0..15)
			PD6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-down bit y\n              (y=0..15)
			PD5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-down bit y\n              (y=0..15)
			PD4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-down bit y\n              (y=0..15)
			PD3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-down bit y\n              (y=0..15)
			PD2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-down bit y\n              (y=0..15)
			PD1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port C pull-down bit y\n              (y=0..15)
			PD0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Power Port D pull-up control\n          register
		PUCRD {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x38, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port D pull-up bit y\n              (y=0..15)
			PU15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port D pull-up bit y\n              (y=0..15)
			PU14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port D pull-up bit y\n              (y=0..15)
			PU13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port D pull-up bit y\n              (y=0..15)
			PU12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port D pull-up bit y\n              (y=0..15)
			PU11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port D pull-up bit y\n              (y=0..15)
			PU10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port D pull-up bit y\n              (y=0..15)
			PU9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port D pull-up bit y\n              (y=0..15)
			PU8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port D pull-up bit y\n              (y=0..15)
			PU7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port D pull-up bit y\n              (y=0..15)
			PU6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port D pull-up bit y\n              (y=0..15)
			PU5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port D pull-up bit y\n              (y=0..15)
			PU4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port D pull-up bit y\n              (y=0..15)
			PU3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port D pull-up bit y\n              (y=0..15)
			PU2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port D pull-up bit y\n              (y=0..15)
			PU1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port D pull-up bit y\n              (y=0..15)
			PU0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Power Port D pull-down control\n          register
		PDCRD {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x3C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port D pull-down bit y\n              (y=0..15)
			PD15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port D pull-down bit y\n              (y=0..15)
			PD14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port D pull-down bit y\n              (y=0..15)
			PD13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port D pull-down bit y\n              (y=0..15)
			PD12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port D pull-down bit y\n              (y=0..15)
			PD11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port D pull-down bit y\n              (y=0..15)
			PD10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port D pull-down bit y\n              (y=0..15)
			PD9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port D pull-down bit y\n              (y=0..15)
			PD8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port D pull-down bit y\n              (y=0..15)
			PD7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port D pull-down bit y\n              (y=0..15)
			PD6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port D pull-down bit y\n              (y=0..15)
			PD5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port D pull-down bit y\n              (y=0..15)
			PD4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port D pull-down bit y\n              (y=0..15)
			PD3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port D pull-down bit y\n              (y=0..15)
			PD2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port D pull-down bit y\n              (y=0..15)
			PD1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port D pull-down bit y\n              (y=0..15)
			PD0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Power Port E pull-UP control\n          register
		PUCRE {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x40, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port E pull-up bit y\n              (y=0..15)
			PU15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port E pull-up bit y\n              (y=0..15)
			PU14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port E pull-up bit y\n              (y=0..15)
			PU13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port E pull-up bit y\n              (y=0..15)
			PU12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port E pull-up bit y\n              (y=0..15)
			PU11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port E pull-up bit y\n              (y=0..15)
			PU10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port E pull-up bit y\n              (y=0..15)
			PU9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port E pull-up bit y\n              (y=0..15)
			PU8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port E pull-up bit y\n              (y=0..15)
			PU7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port E pull-up bit y\n              (y=0..15)
			PU6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port E pull-up bit y\n              (y=0..15)
			PU5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port E pull-up bit y\n              (y=0..15)
			PU4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port E pull-up bit y\n              (y=0..15)
			PU3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port E pull-up bit y\n              (y=0..15)
			PU2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port E pull-up bit y\n              (y=0..15)
			PU1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port E pull-up bit y\n              (y=0..15)
			PU0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Power Port E pull-down control\n          register
		PDCRE {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x44, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port E pull-down bit y\n              (y=0..15)
			PD15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port E pull-down bit y\n              (y=0..15)
			PD14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port E pull-down bit y\n              (y=0..15)
			PD13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port E pull-down bit y\n              (y=0..15)
			PD12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port E pull-down bit y\n              (y=0..15)
			PD11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port E pull-down bit y\n              (y=0..15)
			PD10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port E pull-down bit y\n              (y=0..15)
			PD9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port E pull-down bit y\n              (y=0..15)
			PD8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port E pull-down bit y\n              (y=0..15)
			PD7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port E pull-down bit y\n              (y=0..15)
			PD6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port E pull-down bit y\n              (y=0..15)
			PD5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port E pull-down bit y\n              (y=0..15)
			PD4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port E pull-down bit y\n              (y=0..15)
			PD3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port E pull-down bit y\n              (y=0..15)
			PD2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port E pull-down bit y\n              (y=0..15)
			PD1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port E pull-down bit y\n              (y=0..15)
			PD0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Power Port F pull-up control\n          register
		PUCRF {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x48, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port F pull-up bit y\n              (y=0..15)
			PU13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port F pull-up bit y\n              (y=0..15)
			PU12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port F pull-up bit y\n              (y=0..15)
			PU11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port F pull-up bit y\n              (y=0..15)
			PU10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port F pull-up bit y\n              (y=0..15)
			PU9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port F pull-up bit y\n              (y=0..15)
			PU8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port F pull-up bit y\n              (y=0..15)
			PU7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port F pull-up bit y\n              (y=0..15)
			PU6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port F pull-up bit y\n              (y=0..15)
			PU5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port F pull-up bit y\n              (y=0..15)
			PU4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port F pull-up bit y\n              (y=0..15)
			PU3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port F pull-up bit y\n              (y=0..15)
			PU2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port F pull-up bit y\n              (y=0..15)
			PU1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port F pull-up bit y\n              (y=0..15)
			PU0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Power Port F pull-down control\n          register
		PDCRF {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x4C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port F pull-down bit y\n              (y=0..15)
			PD13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port F pull-down bit y\n              (y=0..15)
			PD12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port F pull-down bit y\n              (y=0..15)
			PD11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port F pull-down bit y\n              (y=0..15)
			PD10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port F pull-down bit y\n              (y=0..15)
			PD9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port F pull-down bit y\n              (y=0..15)
			PD8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port F pull-down bit y\n              (y=0..15)
			PD7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port F pull-down bit y\n              (y=0..15)
			PD6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port F pull-down bit y\n              (y=0..15)
			PD5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port F pull-down bit y\n              (y=0..15)
			PD4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port F pull-down bit y\n              (y=0..15)
			PD3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port F pull-down bit y\n              (y=0..15)
			PD2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port F pull-down bit y\n              (y=0..15)
			PD1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port F pull-down bit y\n              (y=0..15)
			PD0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief DMA controller
	DMA1 {
		ec.Peripheral : {0}
		ec.Size : {size : {0x400, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x40020000, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief DMA interrupt status register 
		DMA_ISR {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief global interrupt flag for channel 1
			GIF1 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer complete (TC) flag for channel 1
			TCIF1 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief half transfer (HT) flag for channel 1
			HTIF1 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer error (TE) flag for channel 1
			TEIF1 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief global interrupt flag for channel 2
			GIF2 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer complete (TC) flag for channel 2
			TCIF2 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief half transfer (HT) flag for channel 2
			HTIF2 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer error (TE) flag for channel 2
			TEIF2 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief global interrupt flag for channel 3
			GIF3 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer complete (TC) flag for channel 3
			TCIF3 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief half transfer (HT) flag for channel 3
			HTIF3 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer error (TE) flag for channel 3
			TEIF3 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief global interrupt flag for channel 4
			GIF4 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer complete (TC) flag for channel 4
			TCIF4 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief half transfer (HT) flag for channel 4
			HTIF4 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer error (TE) flag for channel 4
			TEIF4 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief global interrupt flag for channel 5
			GIF5 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer complete (TC) flag for channel 5
			TCIF5 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief half transfer (HT) flag for channel 5
			HTIF5 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer error (TE) flag for channel 5
			TEIF5 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief global interrupt flag for channel 6
			GIF6 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer complete (TC) flag for channel 6
			TCIF6 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief half transfer (HT) flag for channel 6
			HTIF6 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer error (TE) flag for channel 6
			TEIF6 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief global interrupt flag for channel 7
			GIF7 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer complete (TC) flag for channel 7
			TCIF7 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {25, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief half transfer (HT) flag for channel 7
			HTIF7 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer error (TE) flag for channel 7
			TEIF7 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {27, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA interrupt flag clear register 
		DMA_IFCR {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x4, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief global interrupt flag clear for channel 1
			CGIF1 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer complete flag clear for channel 1
			CTCIF1 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief half transfer flag clear for channel 1
			CHTIF1 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer error flag clear for channel 1
			CTEIF1 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief global interrupt flag clear for channel 2
			CGIF2 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer complete flag clear for channel 2
			CTCIF2 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief half transfer flag clear for channel 2
			CHTIF2 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer error flag clear for channel 2
			CTEIF2 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief global interrupt flag clear for channel 3
			CGIF3 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer complete flag clear for channel 3
			CTCIF3 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief half transfer flag clear for channel 3
			CHTIF3 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer error flag clear for channel 3
			CTEIF3 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief global interrupt flag clear for channel 4
			CGIF4 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer complete flag clear for channel 4
			CTCIF4 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief half transfer flag clear for channel 4
			CHTIF4 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer error flag clear for channel 4
			CTEIF4 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief global interrupt flag clear for channel 5
			CGIF5 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer complete flag clear for channel 5
			CTCIF5 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief half transfer flag clear for channel 5
			CHTIF5 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer error flag clear for channel 5
			CTEIF5 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief global interrupt flag clear for channel 6
			CGIF6 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer complete flag clear for channel 6
			CTCIF6 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief half transfer flag clear for channel 6
			CHTIF6 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer error flag clear for channel 6
			CTEIF6 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief global interrupt flag clear for channel 7
			CGIF7 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer complete flag clear for channel 7
			CTCIF7 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {25, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief half transfer flag clear for channel 7
			CHTIF7 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer error flag clear for channel 7
			CTEIF7 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {27, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel 1 configuration register
		DMA_CCR1 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x8, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief channel enable\nWhen a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register).
			EN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer complete interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			TCIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief half transfer interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			HTIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer error interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			TEIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief data transfer direction\nThis bit must be set only in memory-to-peripheral and peripheral-to-memory modes.\nSource attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nDestination attributes 
			DIR {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief circular mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			CIRC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief peripheral increment mode\nDefines the increment mode for each DMA transfer to the identified peripheral.\nn memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0.\nIn peripheral-to-peripheral mode, this 
			PINC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief memory increment mode\nDefines the increment mode for each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0.\nIn peripheral-to-peripheral mode, this field i
			MINC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief peripheral size\nDefines the data size of each DMA transfer to the identified peripheral.\nIn memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0.\nIn peripheral-to-peripheral mode, this field identifie
			PSIZE {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief memory size\nDefines the data size of each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0.\nIn peripheral-to-peripheral mode, this field identifies the pe
			MSIZE {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief priority level\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1).
			PL {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief memory-to-memory mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1).
			MEM2MEM {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel x number of data register
		DMA_CNDTR1 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xc, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief number of data to transfer (0 to 216-1)\nThis field is updated by hardware when the channel is enabled:\nIt is decremented after each single DMA 'read followed by write' transfer, indicating the remaining amount of data items to transfer.\nIt is kept at zero
			NDT {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel x peripheral address register
		DMA_CPAR1 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief peripheral address\nIt contains the base address of the peripheral data register from/to which the data will be read/written.\nWhen PSIZE[1:0]=01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen PSIZE=10 
			PA {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel x memory address register
		DMA_CMAR1 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x14, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief peripheral address\nIt contains the base address of the memory from/to which the data will be read/written.\nWhen MSIZE[1:0]=01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen MSIZE=10 (32 bits), bits 1 
			MA {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel 2 configuration register
		DMA_CCR2 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x1c, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief channel enable\nWhen a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register).
			EN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer complete interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			TCIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief half transfer interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			HTIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer error interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			TEIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief data transfer direction\nThis bit must be set only in memory-to-peripheral and peripheral-to-memory modes.\nSource attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nDestination attributes 
			DIR {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief circular mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			CIRC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief peripheral increment mode\nDefines the increment mode for each DMA transfer to the identified peripheral.\nn memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0.\nIn peripheral-to-peripheral mode, this 
			PINC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief memory increment mode\nDefines the increment mode for each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0.\nIn peripheral-to-peripheral mode, this field i
			MINC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief peripheral size\nDefines the data size of each DMA transfer to the identified peripheral.\nIn memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0.\nIn peripheral-to-peripheral mode, this field identifie
			PSIZE {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief memory size\nDefines the data size of each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0.\nIn peripheral-to-peripheral mode, this field identifies the pe
			MSIZE {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief priority level\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1).
			PL {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief memory-to-memory mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1).
			MEM2MEM {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel x number of data register
		DMA_CNDTR2 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x20, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief number of data to transfer (0 to 216-1)\nThis field is updated by hardware when the channel is enabled:\nIt is decremented after each single DMA 'read followed by write' transfer, indicating the remaining amount of data items to transfer.\nIt is kept at zero
			NDT {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel x peripheral address register
		DMA_CPAR2 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x24, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief peripheral address\nIt contains the base address of the peripheral data register from/to which the data will be read/written.\nWhen PSIZE[1:0]=01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen PSIZE=10 
			PA {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel x memory address register
		DMA_CMAR2 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x28, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief peripheral address\nIt contains the base address of the memory from/to which the data will be read/written.\nWhen MSIZE[1:0]=01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen MSIZE=10 (32 bits), bits 1 
			MA {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel 3 configuration register
		DMA_CCR3 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x30, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief channel enable\nWhen a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register).
			EN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer complete interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			TCIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief half transfer interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			HTIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer error interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			TEIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief data transfer direction\nThis bit must be set only in memory-to-peripheral and peripheral-to-memory modes.\nSource attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nDestination attributes 
			DIR {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief circular mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			CIRC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief peripheral increment mode\nDefines the increment mode for each DMA transfer to the identified peripheral.\nn memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0.\nIn peripheral-to-peripheral mode, this 
			PINC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief memory increment mode\nDefines the increment mode for each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0.\nIn peripheral-to-peripheral mode, this field i
			MINC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief peripheral size\nDefines the data size of each DMA transfer to the identified peripheral.\nIn memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0.\nIn peripheral-to-peripheral mode, this field identifie
			PSIZE {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief memory size\nDefines the data size of each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0.\nIn peripheral-to-peripheral mode, this field identifies the pe
			MSIZE {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief priority level\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1).
			PL {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief memory-to-memory mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1).
			MEM2MEM {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel x configuration register
		DMA_CNDTR3 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x34, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief number of data to transfer (0 to 216-1)\nThis field is updated by hardware when the channel is enabled:\nIt is decremented after each single DMA 'read followed by write' transfer, indicating the remaining amount of data items to transfer.\nIt is kept at zero
			NDT {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel x peripheral address register
		DMA_CPAR3 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x38, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief peripheral address\nIt contains the base address of the peripheral data register from/to which the data will be read/written.\nWhen PSIZE[1:0]=01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen PSIZE=10 
			PA {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel x memory address register
		DMA_CMAR3 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x3c, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief peripheral address\nIt contains the base address of the memory from/to which the data will be read/written.\nWhen MSIZE[1:0]=01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen MSIZE=10 (32 bits), bits 1 
			MA {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel 4 configuration register
		DMA_CCR4 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x44, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief channel enable\nWhen a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register).
			EN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer complete interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			TCIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief half transfer interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			HTIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer error interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			TEIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief data transfer direction\nThis bit must be set only in memory-to-peripheral and peripheral-to-memory modes.\nSource attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nDestination attributes 
			DIR {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief circular mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			CIRC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief peripheral increment mode\nDefines the increment mode for each DMA transfer to the identified peripheral.\nn memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0.\nIn peripheral-to-peripheral mode, this 
			PINC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief memory increment mode\nDefines the increment mode for each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0.\nIn peripheral-to-peripheral mode, this field i
			MINC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief peripheral size\nDefines the data size of each DMA transfer to the identified peripheral.\nIn memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0.\nIn peripheral-to-peripheral mode, this field identifie
			PSIZE {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief memory size\nDefines the data size of each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0.\nIn peripheral-to-peripheral mode, this field identifies the pe
			MSIZE {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief priority level\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1).
			PL {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief memory-to-memory mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1).
			MEM2MEM {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel x configuration register
		DMA_CNDTR4 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x48, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief number of data to transfer (0 to 216-1)\nThis field is updated by hardware when the channel is enabled:\nIt is decremented after each single DMA 'read followed by write' transfer, indicating the remaining amount of data items to transfer.\nIt is kept at zero
			NDT {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel x peripheral address register
		DMA_CPAR4 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x4c, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief peripheral address\nIt contains the base address of the peripheral data register from/to which the data will be read/written.\nWhen PSIZE[1:0]=01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen PSIZE=10 
			PA {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel x memory address register
		DMA_CMAR4 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x50, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief peripheral address\nIt contains the base address of the memory from/to which the data will be read/written.\nWhen MSIZE[1:0]=01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen MSIZE=10 (32 bits), bits 1 
			MA {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel 5 configuration register
		DMA_CCR5 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x58, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief channel enable\nWhen a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register).
			EN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer complete interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			TCIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief half transfer interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			HTIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer error interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			TEIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief data transfer direction\nThis bit must be set only in memory-to-peripheral and peripheral-to-memory modes.\nSource attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nDestination attributes 
			DIR {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief circular mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			CIRC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief peripheral increment mode\nDefines the increment mode for each DMA transfer to the identified peripheral.\nn memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0.\nIn peripheral-to-peripheral mode, this 
			PINC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief memory increment mode\nDefines the increment mode for each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0.\nIn peripheral-to-peripheral mode, this field i
			MINC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief peripheral size\nDefines the data size of each DMA transfer to the identified peripheral.\nIn memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0.\nIn peripheral-to-peripheral mode, this field identifie
			PSIZE {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief memory size\nDefines the data size of each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0.\nIn peripheral-to-peripheral mode, this field identifies the pe
			MSIZE {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief priority level\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1).
			PL {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief memory-to-memory mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1).
			MEM2MEM {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel x configuration register
		DMA_CNDTR5 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x5c, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief number of data to transfer (0 to 216-1)\nThis field is updated by hardware when the channel is enabled:\nIt is decremented after each single DMA 'read followed by write' transfer, indicating the remaining amount of data items to transfer.\nIt is kept at zero
			NDT {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel x peripheral address register
		DMA_CPAR5 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x60, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief peripheral address\nIt contains the base address of the peripheral data register from/to which the data will be read/written.\nWhen PSIZE[1:0]=01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen PSIZE=10 
			PA {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel x memory address register
		DMA_CMAR5 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x64, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief peripheral address\nIt contains the base address of the memory from/to which the data will be read/written.\nWhen MSIZE[1:0]=01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen MSIZE=10 (32 bits), bits 1 
			MA {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel 6 configuration register
		DMA_CCR6 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x6c, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief channel enable\nWhen a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register).
			EN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer complete interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			TCIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief half transfer interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			HTIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer error interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			TEIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief data transfer direction\nThis bit must be set only in memory-to-peripheral and peripheral-to-memory modes.\nSource attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nDestination attributes 
			DIR {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief circular mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			CIRC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief peripheral increment mode\nDefines the increment mode for each DMA transfer to the identified peripheral.\nn memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0.\nIn peripheral-to-peripheral mode, this 
			PINC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief memory increment mode\nDefines the increment mode for each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0.\nIn peripheral-to-peripheral mode, this field i
			MINC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief peripheral size\nDefines the data size of each DMA transfer to the identified peripheral.\nIn memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0.\nIn peripheral-to-peripheral mode, this field identifie
			PSIZE {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief memory size\nDefines the data size of each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0.\nIn peripheral-to-peripheral mode, this field identifies the pe
			MSIZE {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief priority level\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1).
			PL {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief memory-to-memory mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1).
			MEM2MEM {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel x configuration register
		DMA_CNDTR6 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x70, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief number of data to transfer (0 to 216-1)\nThis field is updated by hardware when the channel is enabled:\nIt is decremented after each single DMA 'read followed by write' transfer, indicating the remaining amount of data items to transfer.\nIt is kept at zero
			NDT {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel x peripheral address register
		DMA_CPAR6 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x74, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief peripheral address\nIt contains the base address of the peripheral data register from/to which the data will be read/written.\nWhen PSIZE[1:0]=01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen PSIZE=10 
			PA {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel x memory address register
		DMA_CMAR6 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x78, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief peripheral address\nIt contains the base address of the memory from/to which the data will be read/written.\nWhen MSIZE[1:0]=01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen MSIZE=10 (32 bits), bits 1 
			MA {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel 7 configuration register
		DMA_CCR7 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x80, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief channel enable\nWhen a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register).
			EN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer complete interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			TCIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief half transfer interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			HTIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer error interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			TEIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief data transfer direction\nThis bit must be set only in memory-to-peripheral and peripheral-to-memory modes.\nSource attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nDestination attributes 
			DIR {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief circular mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			CIRC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief peripheral increment mode\nDefines the increment mode for each DMA transfer to the identified peripheral.\nn memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0.\nIn peripheral-to-peripheral mode, this 
			PINC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief memory increment mode\nDefines the increment mode for each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0.\nIn peripheral-to-peripheral mode, this field i
			MINC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief peripheral size\nDefines the data size of each DMA transfer to the identified peripheral.\nIn memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0.\nIn peripheral-to-peripheral mode, this field identifie
			PSIZE {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief memory size\nDefines the data size of each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0.\nIn peripheral-to-peripheral mode, this field identifies the pe
			MSIZE {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief priority level\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1).
			PL {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief memory-to-memory mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1).
			MEM2MEM {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel x configuration register
		DMA_CNDTR7 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x84, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief number of data to transfer (0 to 216-1)\nThis field is updated by hardware when the channel is enabled:\nIt is decremented after each single DMA 'read followed by write' transfer, indicating the remaining amount of data items to transfer.\nIt is kept at zero
			NDT {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel x peripheral address register
		DMA_CPAR7 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x88, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief peripheral address\nIt contains the base address of the peripheral data register from/to which the data will be read/written.\nWhen PSIZE[1:0]=01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen PSIZE=10 
			PA {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel x memory address register
		DMA_CMAR7 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x8c, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief peripheral address\nIt contains the base address of the memory from/to which the data will be read/written.\nWhen MSIZE[1:0]=01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen MSIZE=10 (32 bits), bits 1 
			MA {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief DMA controller
	DMA2 {
		ec.Peripheral : {0}
		ec.Size : {size : {0x400, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x40020400, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief DMA interrupt status register 
		DMA_ISR {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief global interrupt flag for channel 1
			GIF1 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer complete (TC) flag for channel 1
			TCIF1 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief half transfer (HT) flag for channel 1
			HTIF1 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer error (TE) flag for channel 1
			TEIF1 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief global interrupt flag for channel 2
			GIF2 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer complete (TC) flag for channel 2
			TCIF2 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief half transfer (HT) flag for channel 2
			HTIF2 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer error (TE) flag for channel 2
			TEIF2 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief global interrupt flag for channel 3
			GIF3 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer complete (TC) flag for channel 3
			TCIF3 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief half transfer (HT) flag for channel 3
			HTIF3 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer error (TE) flag for channel 3
			TEIF3 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief global interrupt flag for channel 4
			GIF4 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer complete (TC) flag for channel 4
			TCIF4 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief half transfer (HT) flag for channel 4
			HTIF4 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer error (TE) flag for channel 4
			TEIF4 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief global interrupt flag for channel 5
			GIF5 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer complete (TC) flag for channel 5
			TCIF5 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief half transfer (HT) flag for channel 5
			HTIF5 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer error (TE) flag for channel 5
			TEIF5 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief global interrupt flag for channel 6
			GIF6 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer complete (TC) flag for channel 6
			TCIF6 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief half transfer (HT) flag for channel 6
			HTIF6 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer error (TE) flag for channel 6
			TEIF6 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief global interrupt flag for channel 7
			GIF7 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer complete (TC) flag for channel 7
			TCIF7 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {25, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief half transfer (HT) flag for channel 7
			HTIF7 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer error (TE) flag for channel 7
			TEIF7 {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {27, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA interrupt flag clear register 
		DMA_IFCR {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x4, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief global interrupt flag clear for channel 1
			CGIF1 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer complete flag clear for channel 1
			CTCIF1 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief half transfer flag clear for channel 1
			CHTIF1 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer error flag clear for channel 1
			CTEIF1 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief global interrupt flag clear for channel 2
			CGIF2 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer complete flag clear for channel 2
			CTCIF2 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief half transfer flag clear for channel 2
			CHTIF2 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer error flag clear for channel 2
			CTEIF2 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief global interrupt flag clear for channel 3
			CGIF3 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer complete flag clear for channel 3
			CTCIF3 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief half transfer flag clear for channel 3
			CHTIF3 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer error flag clear for channel 3
			CTEIF3 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief global interrupt flag clear for channel 4
			CGIF4 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer complete flag clear for channel 4
			CTCIF4 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief half transfer flag clear for channel 4
			CHTIF4 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer error flag clear for channel 4
			CTEIF4 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief global interrupt flag clear for channel 5
			CGIF5 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer complete flag clear for channel 5
			CTCIF5 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief half transfer flag clear for channel 5
			CHTIF5 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer error flag clear for channel 5
			CTEIF5 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief global interrupt flag clear for channel 6
			CGIF6 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer complete flag clear for channel 6
			CTCIF6 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief half transfer flag clear for channel 6
			CHTIF6 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer error flag clear for channel 6
			CTEIF6 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief global interrupt flag clear for channel 7
			CGIF7 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer complete flag clear for channel 7
			CTCIF7 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {25, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief half transfer flag clear for channel 7
			CHTIF7 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer error flag clear for channel 7
			CTEIF7 {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {27, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel 1 configuration register
		DMA_CCR1 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x8, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief channel enable\nWhen a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register).
			EN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer complete interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			TCIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief half transfer interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			HTIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer error interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			TEIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief data transfer direction\nThis bit must be set only in memory-to-peripheral and peripheral-to-memory modes.\nSource attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nDestination attributes 
			DIR {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief circular mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			CIRC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief peripheral increment mode\nDefines the increment mode for each DMA transfer to the identified peripheral.\nn memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0.\nIn peripheral-to-peripheral mode, this 
			PINC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief memory increment mode\nDefines the increment mode for each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0.\nIn peripheral-to-peripheral mode, this field i
			MINC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief peripheral size\nDefines the data size of each DMA transfer to the identified peripheral.\nIn memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0.\nIn peripheral-to-peripheral mode, this field identifie
			PSIZE {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief memory size\nDefines the data size of each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0.\nIn peripheral-to-peripheral mode, this field identifies the pe
			MSIZE {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief priority level\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1).
			PL {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief memory-to-memory mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1).
			MEM2MEM {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel x number of data register
		DMA_CNDTR1 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xc, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief number of data to transfer (0 to 216-1)\nThis field is updated by hardware when the channel is enabled:\nIt is decremented after each single DMA 'read followed by write' transfer, indicating the remaining amount of data items to transfer.\nIt is kept at zero
			NDT {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel x peripheral address register
		DMA_CPAR1 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief peripheral address\nIt contains the base address of the peripheral data register from/to which the data will be read/written.\nWhen PSIZE[1:0]=01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen PSIZE=10 
			PA {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel x memory address register
		DMA_CMAR1 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x14, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief peripheral address\nIt contains the base address of the memory from/to which the data will be read/written.\nWhen MSIZE[1:0]=01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen MSIZE=10 (32 bits), bits 1 
			MA {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel 2 configuration register
		DMA_CCR2 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x1c, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief channel enable\nWhen a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register).
			EN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer complete interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			TCIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief half transfer interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			HTIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer error interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			TEIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief data transfer direction\nThis bit must be set only in memory-to-peripheral and peripheral-to-memory modes.\nSource attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nDestination attributes 
			DIR {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief circular mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			CIRC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief peripheral increment mode\nDefines the increment mode for each DMA transfer to the identified peripheral.\nn memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0.\nIn peripheral-to-peripheral mode, this 
			PINC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief memory increment mode\nDefines the increment mode for each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0.\nIn peripheral-to-peripheral mode, this field i
			MINC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief peripheral size\nDefines the data size of each DMA transfer to the identified peripheral.\nIn memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0.\nIn peripheral-to-peripheral mode, this field identifie
			PSIZE {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief memory size\nDefines the data size of each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0.\nIn peripheral-to-peripheral mode, this field identifies the pe
			MSIZE {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief priority level\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1).
			PL {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief memory-to-memory mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1).
			MEM2MEM {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel x number of data register
		DMA_CNDTR2 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x20, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief number of data to transfer (0 to 216-1)\nThis field is updated by hardware when the channel is enabled:\nIt is decremented after each single DMA 'read followed by write' transfer, indicating the remaining amount of data items to transfer.\nIt is kept at zero
			NDT {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel x peripheral address register
		DMA_CPAR2 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x24, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief peripheral address\nIt contains the base address of the peripheral data register from/to which the data will be read/written.\nWhen PSIZE[1:0]=01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen PSIZE=10 
			PA {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel x memory address register
		DMA_CMAR2 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x28, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief peripheral address\nIt contains the base address of the memory from/to which the data will be read/written.\nWhen MSIZE[1:0]=01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen MSIZE=10 (32 bits), bits 1 
			MA {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel 3 configuration register
		DMA_CCR3 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x30, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief channel enable\nWhen a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register).
			EN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer complete interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			TCIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief half transfer interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			HTIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer error interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			TEIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief data transfer direction\nThis bit must be set only in memory-to-peripheral and peripheral-to-memory modes.\nSource attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nDestination attributes 
			DIR {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief circular mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			CIRC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief peripheral increment mode\nDefines the increment mode for each DMA transfer to the identified peripheral.\nn memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0.\nIn peripheral-to-peripheral mode, this 
			PINC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief memory increment mode\nDefines the increment mode for each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0.\nIn peripheral-to-peripheral mode, this field i
			MINC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief peripheral size\nDefines the data size of each DMA transfer to the identified peripheral.\nIn memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0.\nIn peripheral-to-peripheral mode, this field identifie
			PSIZE {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief memory size\nDefines the data size of each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0.\nIn peripheral-to-peripheral mode, this field identifies the pe
			MSIZE {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief priority level\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1).
			PL {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief memory-to-memory mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1).
			MEM2MEM {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel x configuration register
		DMA_CNDTR3 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x34, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief number of data to transfer (0 to 216-1)\nThis field is updated by hardware when the channel is enabled:\nIt is decremented after each single DMA 'read followed by write' transfer, indicating the remaining amount of data items to transfer.\nIt is kept at zero
			NDT {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel x peripheral address register
		DMA_CPAR3 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x38, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief peripheral address\nIt contains the base address of the peripheral data register from/to which the data will be read/written.\nWhen PSIZE[1:0]=01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen PSIZE=10 
			PA {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel x memory address register
		DMA_CMAR3 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x3c, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief peripheral address\nIt contains the base address of the memory from/to which the data will be read/written.\nWhen MSIZE[1:0]=01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen MSIZE=10 (32 bits), bits 1 
			MA {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel 4 configuration register
		DMA_CCR4 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x44, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief channel enable\nWhen a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register).
			EN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer complete interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			TCIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief half transfer interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			HTIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer error interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			TEIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief data transfer direction\nThis bit must be set only in memory-to-peripheral and peripheral-to-memory modes.\nSource attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nDestination attributes 
			DIR {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief circular mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			CIRC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief peripheral increment mode\nDefines the increment mode for each DMA transfer to the identified peripheral.\nn memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0.\nIn peripheral-to-peripheral mode, this 
			PINC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief memory increment mode\nDefines the increment mode for each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0.\nIn peripheral-to-peripheral mode, this field i
			MINC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief peripheral size\nDefines the data size of each DMA transfer to the identified peripheral.\nIn memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0.\nIn peripheral-to-peripheral mode, this field identifie
			PSIZE {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief memory size\nDefines the data size of each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0.\nIn peripheral-to-peripheral mode, this field identifies the pe
			MSIZE {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief priority level\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1).
			PL {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief memory-to-memory mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1).
			MEM2MEM {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel x configuration register
		DMA_CNDTR4 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x48, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief number of data to transfer (0 to 216-1)\nThis field is updated by hardware when the channel is enabled:\nIt is decremented after each single DMA 'read followed by write' transfer, indicating the remaining amount of data items to transfer.\nIt is kept at zero
			NDT {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel x peripheral address register
		DMA_CPAR4 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x4c, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief peripheral address\nIt contains the base address of the peripheral data register from/to which the data will be read/written.\nWhen PSIZE[1:0]=01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen PSIZE=10 
			PA {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel x memory address register
		DMA_CMAR4 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x50, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief peripheral address\nIt contains the base address of the memory from/to which the data will be read/written.\nWhen MSIZE[1:0]=01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen MSIZE=10 (32 bits), bits 1 
			MA {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel 5 configuration register
		DMA_CCR5 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x58, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief channel enable\nWhen a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register).
			EN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer complete interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			TCIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief half transfer interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			HTIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer error interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			TEIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief data transfer direction\nThis bit must be set only in memory-to-peripheral and peripheral-to-memory modes.\nSource attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nDestination attributes 
			DIR {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief circular mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			CIRC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief peripheral increment mode\nDefines the increment mode for each DMA transfer to the identified peripheral.\nn memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0.\nIn peripheral-to-peripheral mode, this 
			PINC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief memory increment mode\nDefines the increment mode for each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0.\nIn peripheral-to-peripheral mode, this field i
			MINC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief peripheral size\nDefines the data size of each DMA transfer to the identified peripheral.\nIn memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0.\nIn peripheral-to-peripheral mode, this field identifie
			PSIZE {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief memory size\nDefines the data size of each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0.\nIn peripheral-to-peripheral mode, this field identifies the pe
			MSIZE {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief priority level\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1).
			PL {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief memory-to-memory mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1).
			MEM2MEM {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel x configuration register
		DMA_CNDTR5 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x5c, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief number of data to transfer (0 to 216-1)\nThis field is updated by hardware when the channel is enabled:\nIt is decremented after each single DMA 'read followed by write' transfer, indicating the remaining amount of data items to transfer.\nIt is kept at zero
			NDT {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel x peripheral address register
		DMA_CPAR5 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x60, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief peripheral address\nIt contains the base address of the peripheral data register from/to which the data will be read/written.\nWhen PSIZE[1:0]=01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen PSIZE=10 
			PA {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel x memory address register
		DMA_CMAR5 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x64, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief peripheral address\nIt contains the base address of the memory from/to which the data will be read/written.\nWhen MSIZE[1:0]=01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen MSIZE=10 (32 bits), bits 1 
			MA {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel 6 configuration register
		DMA_CCR6 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x6c, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief channel enable\nWhen a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register).
			EN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer complete interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			TCIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief half transfer interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			HTIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer error interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			TEIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief data transfer direction\nThis bit must be set only in memory-to-peripheral and peripheral-to-memory modes.\nSource attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nDestination attributes 
			DIR {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief circular mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			CIRC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief peripheral increment mode\nDefines the increment mode for each DMA transfer to the identified peripheral.\nn memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0.\nIn peripheral-to-peripheral mode, this 
			PINC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief memory increment mode\nDefines the increment mode for each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0.\nIn peripheral-to-peripheral mode, this field i
			MINC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief peripheral size\nDefines the data size of each DMA transfer to the identified peripheral.\nIn memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0.\nIn peripheral-to-peripheral mode, this field identifie
			PSIZE {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief memory size\nDefines the data size of each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0.\nIn peripheral-to-peripheral mode, this field identifies the pe
			MSIZE {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief priority level\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1).
			PL {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief memory-to-memory mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1).
			MEM2MEM {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel x configuration register
		DMA_CNDTR6 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x70, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief number of data to transfer (0 to 216-1)\nThis field is updated by hardware when the channel is enabled:\nIt is decremented after each single DMA 'read followed by write' transfer, indicating the remaining amount of data items to transfer.\nIt is kept at zero
			NDT {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel x peripheral address register
		DMA_CPAR6 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x74, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief peripheral address\nIt contains the base address of the peripheral data register from/to which the data will be read/written.\nWhen PSIZE[1:0]=01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen PSIZE=10 
			PA {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel x memory address register
		DMA_CMAR6 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x78, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief peripheral address\nIt contains the base address of the memory from/to which the data will be read/written.\nWhen MSIZE[1:0]=01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen MSIZE=10 (32 bits), bits 1 
			MA {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel 7 configuration register
		DMA_CCR7 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x80, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief channel enable\nWhen a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register).
			EN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer complete interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			TCIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief half transfer interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			HTIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief transfer error interrupt enable\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			TEIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief data transfer direction\nThis bit must be set only in memory-to-peripheral and peripheral-to-memory modes.\nSource attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.\nDestination attributes 
			DIR {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief circular mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is not read-only when the channel is enabled (EN=1).
			CIRC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief peripheral increment mode\nDefines the increment mode for each DMA transfer to the identified peripheral.\nn memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0.\nIn peripheral-to-peripheral mode, this 
			PINC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief memory increment mode\nDefines the increment mode for each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0.\nIn peripheral-to-peripheral mode, this field i
			MINC {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief peripheral size\nDefines the data size of each DMA transfer to the identified peripheral.\nIn memory-to-memory mode, this field identifies the memory destination if DIR=1 and the memory source if DIR=0.\nIn peripheral-to-peripheral mode, this field identifie
			PSIZE {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief memory size\nDefines the data size of each DMA transfer to the identified memory.\nIn memory-to-memory mode, this field identifies the memory source if DIR=1 and the memory destination if DIR=0.\nIn peripheral-to-peripheral mode, this field identifies the pe
			MSIZE {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief priority level\nNote: this field is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1).
			PL {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief memory-to-memory mode\nNote: this bit is set and cleared by software.\nIt must not be written when the channel is enabled (EN = 1).\nIt is read-only when the channel is enabled (EN=1).
			MEM2MEM {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel x configuration register
		DMA_CNDTR7 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x84, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief number of data to transfer (0 to 216-1)\nThis field is updated by hardware when the channel is enabled:\nIt is decremented after each single DMA 'read followed by write' transfer, indicating the remaining amount of data items to transfer.\nIt is kept at zero
			NDT {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel x peripheral address register
		DMA_CPAR7 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x88, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief peripheral address\nIt contains the base address of the peripheral data register from/to which the data will be read/written.\nWhen PSIZE[1:0]=01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen PSIZE=10 
			PA {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA channel x memory address register
		DMA_CMAR7 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x8c, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief peripheral address\nIt contains the base address of the memory from/to which the data will be read/written.\nWhen MSIZE[1:0]=01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address.\nWhen MSIZE=10 (32 bits), bits 1 
			MA {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief DMAMUX
	DMAMUX {
		ec.Peripheral : {0}
		ec.Size : {size : {0x400, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x40020800, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief DMAMux - DMA request line multiplexer\n          channel x control register
		C0CR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Input DMA request line\n              selected
			DMAREQ_ID {
				ec.Access : {0}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Interrupt enable at synchronization\n              event overrun
			SOIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Event generation\n              enable/disable
			EGE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Synchronous operating mode\n              enable/disable
			SE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Synchronization event type selector\n              Defines the synchronization event on the selected\n              synchronization input:
			SPOL {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Number of DMA requests to forward\n              Defines the number of DMA requests forwarded before\n              output event is generated. In synchronous mode, it\n              also defines the number of DMA requests to forward\n              after a syn
			NBREQ {
				ec.Access : {0}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Synchronization input\n              selected
			SYNC_ID {
				ec.Access : {0}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMAMux - DMA request line multiplexer\n          channel x control register
		C1CR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x4, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Input DMA request line\n              selected
			DMAREQ_ID {
				ec.Access : {0}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Interrupt enable at synchronization\n              event overrun
			SOIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Event generation\n              enable/disable
			EGE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Synchronous operating mode\n              enable/disable
			SE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Synchronization event type selector\n              Defines the synchronization event on the selected\n              synchronization input:
			SPOL {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Number of DMA requests to forward\n              Defines the number of DMA requests forwarded before\n              output event is generated. In synchronous mode, it\n              also defines the number of DMA requests to forward\n              after a syn
			NBREQ {
				ec.Access : {0}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Synchronization input\n              selected
			SYNC_ID {
				ec.Access : {0}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMAMux - DMA request line multiplexer\n          channel x control register
		C2CR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x8, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Input DMA request line\n              selected
			DMAREQ_ID {
				ec.Access : {0}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Interrupt enable at synchronization\n              event overrun
			SOIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Event generation\n              enable/disable
			EGE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Synchronous operating mode\n              enable/disable
			SE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Synchronization event type selector\n              Defines the synchronization event on the selected\n              synchronization input:
			SPOL {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Number of DMA requests to forward\n              Defines the number of DMA requests forwarded before\n              output event is generated. In synchronous mode, it\n              also defines the number of DMA requests to forward\n              after a syn
			NBREQ {
				ec.Access : {0}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Synchronization input\n              selected
			SYNC_ID {
				ec.Access : {0}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMAMux - DMA request line multiplexer\n          channel x control register
		C3CR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xC, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Input DMA request line\n              selected
			DMAREQ_ID {
				ec.Access : {0}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Interrupt enable at synchronization\n              event overrun
			SOIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Event generation\n              enable/disable
			EGE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Synchronous operating mode\n              enable/disable
			SE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Synchronization event type selector\n              Defines the synchronization event on the selected\n              synchronization input:
			SPOL {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Number of DMA requests to forward\n              Defines the number of DMA requests forwarded before\n              output event is generated. In synchronous mode, it\n              also defines the number of DMA requests to forward\n              after a syn
			NBREQ {
				ec.Access : {0}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Synchronization input\n              selected
			SYNC_ID {
				ec.Access : {0}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMAMux - DMA request line multiplexer\n          channel x control register
		C4CR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Input DMA request line\n              selected
			DMAREQ_ID {
				ec.Access : {0}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Interrupt enable at synchronization\n              event overrun
			SOIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Event generation\n              enable/disable
			EGE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Synchronous operating mode\n              enable/disable
			SE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Synchronization event type selector\n              Defines the synchronization event on the selected\n              synchronization input:
			SPOL {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Number of DMA requests to forward\n              Defines the number of DMA requests forwarded before\n              output event is generated. In synchronous mode, it\n              also defines the number of DMA requests to forward\n              after a syn
			NBREQ {
				ec.Access : {0}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Synchronization input\n              selected
			SYNC_ID {
				ec.Access : {0}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMAMux - DMA request line multiplexer\n          channel x control register
		C5CR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x14, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Input DMA request line\n              selected
			DMAREQ_ID {
				ec.Access : {0}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Interrupt enable at synchronization\n              event overrun
			SOIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Event generation\n              enable/disable
			EGE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Synchronous operating mode\n              enable/disable
			SE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Synchronization event type selector\n              Defines the synchronization event on the selected\n              synchronization input:
			SPOL {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Number of DMA requests to forward\n              Defines the number of DMA requests forwarded before\n              output event is generated. In synchronous mode, it\n              also defines the number of DMA requests to forward\n              after a syn
			NBREQ {
				ec.Access : {0}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Synchronization input\n              selected
			SYNC_ID {
				ec.Access : {0}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMAMux - DMA request line multiplexer\n          channel x control register
		C6CR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Input DMA request line\n              selected
			DMAREQ_ID {
				ec.Access : {0}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Interrupt enable at synchronization\n              event overrun
			SOIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Event generation\n              enable/disable
			EGE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Synchronous operating mode\n              enable/disable
			SE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Synchronization event type selector\n              Defines the synchronization event on the selected\n              synchronization input:
			SPOL {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Number of DMA requests to forward\n              Defines the number of DMA requests forwarded before\n              output event is generated. In synchronous mode, it\n              also defines the number of DMA requests to forward\n              after a syn
			NBREQ {
				ec.Access : {0}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Synchronization input\n              selected
			SYNC_ID {
				ec.Access : {0}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMAMux - DMA request generator channel x\n          control register
		RG0CR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x100, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief DMA request trigger input\n              selected
			SIG_ID {
				ec.Access : {0}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Interrupt enable at trigger event\n              overrun
			OIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA request generator channel\n              enable/disable
			GE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA request generator trigger event type\n              selection Defines the trigger event on the selected\n              DMA request trigger input
			GPOL {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Number of DMA requests to generate\n              Defines the number of DMA requests generated after a\n              trigger event, then stop generating. The actual\n              number of generated DMA requests is GNBREQ+1. Note:\n              This field 
			GNBREQ {
				ec.Access : {0}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMAMux - DMA request generator channel x\n          control register
		RG1CR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x104, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief DMA request trigger input\n              selected
			SIG_ID {
				ec.Access : {0}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Interrupt enable at trigger event\n              overrun
			OIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA request generator channel\n              enable/disable
			GE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA request generator trigger event type\n              selection Defines the trigger event on the selected\n              DMA request trigger input
			GPOL {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Number of DMA requests to generate\n              Defines the number of DMA requests generated after a\n              trigger event, then stop generating. The actual\n              number of generated DMA requests is GNBREQ+1. Note:\n              This field 
			GNBREQ {
				ec.Access : {0}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMAMux - DMA request generator channel x\n          control register
		RG2CR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x108, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief DMA request trigger input\n              selected
			SIG_ID {
				ec.Access : {0}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Interrupt enable at trigger event\n              overrun
			OIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA request generator channel\n              enable/disable
			GE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA request generator trigger event type\n              selection Defines the trigger event on the selected\n              DMA request trigger input
			GPOL {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Number of DMA requests to generate\n              Defines the number of DMA requests generated after a\n              trigger event, then stop generating. The actual\n              number of generated DMA requests is GNBREQ+1. Note:\n              This field 
			GNBREQ {
				ec.Access : {0}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMAMux - DMA request generator channel x\n          control register
		RG3CR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief DMA request trigger input\n              selected
			SIG_ID {
				ec.Access : {0}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Interrupt enable at trigger event\n              overrun
			OIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA request generator channel\n              enable/disable
			GE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA request generator trigger event type\n              selection Defines the trigger event on the selected\n              DMA request trigger input
			GPOL {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Number of DMA requests to generate\n              Defines the number of DMA requests generated after a\n              trigger event, then stop generating. The actual\n              number of generated DMA requests is GNBREQ+1. Note:\n              This field 
			GNBREQ {
				ec.Access : {0}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMAMux - DMA request generator status\n          register
		RGSR {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x140, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Trigger event overrun flag The flag is\n              set when a trigger event occurs on DMA request\n              generator channel x, while the DMA request generator\n              counter value is lower than GNBREQ. The flag is\n              cleared by w
			OF {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMAMux - DMA request generator clear flag\n          register
		RGCFR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x144, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Clear trigger event overrun flag Upon\n              setting, this bit clears the corresponding overrun\n              flag OFx in the DMAMUX_RGCSR register.
			COF {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief General-purpose I/Os
	GPIOA {
		ec.Peripheral : {0}
		ec.Size : {size : {0x400, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x50000000, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief GPIO port mode register
		MODER {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER15 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER14 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER13 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER12 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER11 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER10 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER9 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER8 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER7 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER6 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER5 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER4 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER3 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER2 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER1 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER0 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port output type register
		OTYPER {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x4, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port output speed\n          register
		OSPEEDR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x8, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR15 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR14 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR13 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR12 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR11 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR10 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR9 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR8 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR7 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR6 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR5 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR4 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR3 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR2 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR1 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR0 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port pull-up/pull-down\n          register
		PUPDR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xC, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR15 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR14 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR13 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR12 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR11 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR10 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR9 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR8 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR7 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR6 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR5 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR4 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR3 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR2 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR1 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR0 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port input data register
		IDR {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port output data register
		ODR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x14, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port bit set/reset\n          register
		BSRR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {31, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {29, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {27, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {25, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BR0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port configuration lock\n          register
		LCKR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x1C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCKK {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO alternate function low\n          register
		AFRL {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x20, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 0..7)
			AFSEL7 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 0..7)
			AFSEL6 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 0..7)
			AFSEL5 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 0..7)
			AFSEL4 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 0..7)
			AFSEL3 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 0..7)
			AFSEL2 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 0..7)
			AFSEL1 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 0..7)
			AFSEL0 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO alternate function high\n          register
		AFRH {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x24, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 8..15)
			AFSEL15 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 8..15)
			AFSEL14 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 8..15)
			AFSEL13 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 8..15)
			AFSEL12 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 8..15)
			AFSEL11 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 8..15)
			AFSEL10 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 8..15)
			AFSEL9 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 8..15)
			AFSEL8 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief port bit reset register
		BRR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x28, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port Reset bit
			BR0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief General-purpose I/Os
	GPIOB {
		ec.Peripheral : {0}
		ec.Size : {size : {0x400, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x50000400, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief GPIO port mode register
		MODER {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER15 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER14 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER13 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER12 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER11 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER10 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER9 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER8 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER7 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER6 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER5 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER4 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER3 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER2 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER1 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER0 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port output type register
		OTYPER {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x4, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port output speed\n          register
		OSPEEDR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x8, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR15 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR14 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR13 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR12 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR11 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR10 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR9 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR8 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR7 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR6 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR5 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR4 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR3 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR2 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR1 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR0 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port pull-up/pull-down\n          register
		PUPDR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xC, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR15 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR14 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR13 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR12 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR11 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR10 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR9 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR8 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR7 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR6 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR5 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR4 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR3 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR2 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR1 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR0 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port input data register
		IDR {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port output data register
		ODR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x14, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port bit set/reset\n          register
		BSRR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {31, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {29, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {27, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {25, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BR0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port configuration lock\n          register
		LCKR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x1C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCKK {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO alternate function low\n          register
		AFRL {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x20, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 0..7)
			AFSEL7 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 0..7)
			AFSEL6 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 0..7)
			AFSEL5 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 0..7)
			AFSEL4 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 0..7)
			AFSEL3 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 0..7)
			AFSEL2 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 0..7)
			AFSEL1 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 0..7)
			AFSEL0 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO alternate function high\n          register
		AFRH {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x24, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 8..15)
			AFSEL15 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 8..15)
			AFSEL14 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 8..15)
			AFSEL13 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 8..15)
			AFSEL12 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 8..15)
			AFSEL11 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 8..15)
			AFSEL10 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 8..15)
			AFSEL9 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 8..15)
			AFSEL8 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief port bit reset register
		BRR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x28, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port Reset bit
			BR0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief General-purpose I/Os
	GPIOC {
		ec.Peripheral : {0}
		ec.Size : {size : {0x400, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x50000800, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief GPIO port mode register
		MODER {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER15 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER14 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER13 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER12 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER11 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER10 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER9 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER8 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER7 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER6 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER5 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER4 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER3 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER2 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER1 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER0 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port output type register
		OTYPER {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x4, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port output speed\n          register
		OSPEEDR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x8, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR15 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR14 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR13 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR12 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR11 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR10 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR9 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR8 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR7 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR6 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR5 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR4 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR3 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR2 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR1 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR0 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port pull-up/pull-down\n          register
		PUPDR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xC, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR15 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR14 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR13 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR12 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR11 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR10 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR9 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR8 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR7 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR6 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR5 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR4 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR3 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR2 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR1 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR0 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port input data register
		IDR {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port output data register
		ODR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x14, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port bit set/reset\n          register
		BSRR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {31, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {29, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {27, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {25, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BR0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port configuration lock\n          register
		LCKR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x1C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCKK {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO alternate function low\n          register
		AFRL {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x20, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 0..7)
			AFSEL7 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 0..7)
			AFSEL6 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 0..7)
			AFSEL5 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 0..7)
			AFSEL4 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 0..7)
			AFSEL3 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 0..7)
			AFSEL2 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 0..7)
			AFSEL1 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 0..7)
			AFSEL0 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO alternate function high\n          register
		AFRH {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x24, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 8..15)
			AFSEL15 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 8..15)
			AFSEL14 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 8..15)
			AFSEL13 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 8..15)
			AFSEL12 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 8..15)
			AFSEL11 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 8..15)
			AFSEL10 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 8..15)
			AFSEL9 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 8..15)
			AFSEL8 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief port bit reset register
		BRR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x28, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port Reset bit
			BR0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief General-purpose I/Os
	GPIOD {
		ec.Peripheral : {0}
		ec.Size : {size : {0x400, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x50000C00, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief GPIO port mode register
		MODER {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER15 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER14 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER13 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER12 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER11 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER10 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER9 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER8 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER7 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER6 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER5 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER4 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER3 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER2 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER1 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER0 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port output type register
		OTYPER {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x4, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port output speed\n          register
		OSPEEDR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x8, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR15 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR14 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR13 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR12 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR11 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR10 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR9 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR8 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR7 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR6 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR5 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR4 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR3 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR2 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR1 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR0 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port pull-up/pull-down\n          register
		PUPDR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xC, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR15 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR14 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR13 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR12 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR11 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR10 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR9 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR8 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR7 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR6 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR5 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR4 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR3 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR2 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR1 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR0 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port input data register
		IDR {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port output data register
		ODR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x14, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port bit set/reset\n          register
		BSRR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {31, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {29, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {27, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {25, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BR0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port configuration lock\n          register
		LCKR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x1C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCKK {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO alternate function low\n          register
		AFRL {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x20, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 0..7)
			AFSEL7 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 0..7)
			AFSEL6 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 0..7)
			AFSEL5 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 0..7)
			AFSEL4 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 0..7)
			AFSEL3 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 0..7)
			AFSEL2 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 0..7)
			AFSEL1 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 0..7)
			AFSEL0 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO alternate function high\n          register
		AFRH {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x24, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 8..15)
			AFSEL15 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 8..15)
			AFSEL14 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 8..15)
			AFSEL13 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 8..15)
			AFSEL12 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 8..15)
			AFSEL11 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 8..15)
			AFSEL10 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 8..15)
			AFSEL9 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 8..15)
			AFSEL8 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief port bit reset register
		BRR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x28, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port Reset bit
			BR0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief General-purpose I/Os
	GPIOF {
		ec.Peripheral : {0}
		ec.Size : {size : {0x400, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x50001400, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief GPIO port mode register
		MODER {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER15 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER14 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER13 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER12 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER11 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER10 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER9 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER8 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER7 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER6 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER5 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER4 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER3 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER2 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER1 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			MODER0 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port output type register
		OTYPER {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x4, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OT0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port output speed\n          register
		OSPEEDR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x8, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR15 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR14 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR13 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR12 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR11 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR10 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR9 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR8 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR7 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR6 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR5 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR4 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR3 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR2 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR1 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			OSPEEDR0 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port pull-up/pull-down\n          register
		PUPDR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xC, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR15 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR14 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR13 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR12 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR11 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR10 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR9 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR8 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR7 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR6 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR5 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR4 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR3 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR2 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR1 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x configuration bits (y =\n              0..15)
			PUPDR0 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port input data register
		IDR {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port input data (y =\n              0..15)
			IDR0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port output data register
		ODR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x14, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port output data (y =\n              0..15)
			ODR0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port bit set/reset\n          register
		BSRR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {31, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {29, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {27, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {25, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x reset bit y (y =\n              0..15)
			BR1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BR0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x set bit y (y=\n              0..15)
			BS0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO port configuration lock\n          register
		LCKR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x1C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCKK {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port x lock bit y (y=\n              0..15)
			LCK0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO alternate function low\n          register
		AFRL {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x20, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 0..7)
			AFSEL7 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 0..7)
			AFSEL6 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 0..7)
			AFSEL5 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 0..7)
			AFSEL4 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 0..7)
			AFSEL3 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 0..7)
			AFSEL2 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 0..7)
			AFSEL1 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 0..7)
			AFSEL0 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief GPIO alternate function high\n          register
		AFRH {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x24, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 8..15)
			AFSEL15 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 8..15)
			AFSEL14 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 8..15)
			AFSEL13 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 8..15)
			AFSEL12 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 8..15)
			AFSEL11 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 8..15)
			AFSEL10 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 8..15)
			AFSEL9 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alternate function selection for port x\n              bit y (y = 8..15)
			AFSEL8 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief port bit reset register
		BRR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x28, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Port Reset bit
			BR0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Port Reset bit
			BR15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief Cyclic redundancy check calculation\n      unit
	CRC {
		ec.Peripheral : {0}
		ec.Size : {size : {0x400, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x40023000, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief Data register
		DR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Data register bits
			DR {
				ec.Access : {0}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Independent data register
		IDR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x4, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief General-purpose 32-bit data register\n              bits
			IDR {
				ec.Access : {0}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Control register
		CR {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x8, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Reverse output data
			REV_OUT {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Reverse input data
			REV_IN {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Polynomial size
			POLYSIZE {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RESET bit
			RESET {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Initial CRC value
		INIT {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Programmable initial CRC\n              value
			CRC_INIT {
				ec.Access : {0}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief polynomial
		POL {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x14, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Programmable polynomial
			POL {
				ec.Access : {0}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief External interrupt/event\n      controller
	EXTI {
		ec.Peripheral : {0}
		ec.Size : {size : {0x400, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x40021800, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief EXTI rising trigger selection\n          register
		RTSR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Rising trigger event configuration bit\n              of Configurable Event line
			RT0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising trigger event configuration bit\n              of Configurable Event line
			RT1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising trigger event configuration bit\n              of Configurable Event line
			RT2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising trigger event configuration bit\n              of Configurable Event line
			RT3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising trigger event configuration bit\n              of Configurable Event line
			RT4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising trigger event configuration bit\n              of Configurable Event line
			RT5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising trigger event configuration bit\n              of Configurable Event line
			RT6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising trigger event configuration bit\n              of Configurable Event line
			RT7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising trigger event configuration bit\n              of Configurable Event line
			RT8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising trigger event configuration bit\n              of Configurable Event line
			RT9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising trigger event configuration bit\n              of Configurable Event line
			RT10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising trigger event configuration bit\n              of Configurable Event line
			RT11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising trigger event configuration bit\n              of Configurable Event line
			RT12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising trigger event configuration bit\n              of Configurable Event line
			RT13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising trigger event configuration bit\n              of Configurable Event line
			RT14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising trigger event configuration bit\n              of Configurable Event line
			RT15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief EXTI falling trigger selection\n          register
		FTSR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x4, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Falling trigger event configuration bit of configurable line
			FT0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling trigger event configuration bit of configurable line
			FT1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling trigger event configuration bit of configurable line
			FT2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling trigger event configuration bit of configurable line
			FT3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling trigger event configuration bit of configurable line
			FT4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling trigger event configuration bit of configurable line
			FT5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling trigger event configuration bit of configurable line
			FT6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling trigger event configuration bit of configurable line
			FT7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling trigger event configuration bit of configurable line
			FT8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling trigger event configuration bit of configurable line
			FT9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling trigger event configuration bit of configurable line
			FT10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling trigger event configuration bit of configurable line
			FT11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling trigger event configuration bit of configurable line
			FT12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling trigger event configuration bit of configurable line
			FT13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling trigger event configuration bit of configurable line
			FT14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling trigger event configuration bit of configurable line
			FT15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief EXTI software interrupt event\n          register
		SWIER1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x8, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Software rising edge event trigger on line
			SWI0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Software rising edge event trigger on line
			SWI1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Software rising edge event trigger on line
			SWI2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Software rising edge event trigger on line
			SWI3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Software rising edge event trigger on line
			SWI4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Software rising edge event trigger on line
			SWI5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Software rising edge event trigger on line
			SWI6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Software rising edge event trigger on line
			SWI7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Software rising edge event trigger on line
			SWI8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Software rising edge event trigger on line
			SWI9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Software rising edge event trigger on line
			SWI10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Software rising edge event trigger on line
			SWI11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Software rising edge event trigger on line
			SWI12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Software rising edge event trigger on line
			SWI13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Software rising edge event trigger on line
			SWI14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Software rising edge event trigger on line
			SWI15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief EXTI rising edge pending\n          register
		RPR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xC, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Rising edge event pending for configurable line
			RPIF0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising edge event pending for configurable line
			RPIF1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising edge event pending for configurable line
			RPIF2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising edge event pending for configurable line
			RPIF3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising edge event pending for configurable line
			RPIF4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief configurable event inputs x rising edge\n              Pending bit
			RPIF5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising edge event pending for configurable line
			RPIF6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising edge event pending for configurable line
			RPIF7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising edge event pending for configurable line
			RPIF8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising edge event pending for configurable line
			RPIF9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising edge event pending for configurable line
			RPIF10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising edge event pending for configurable line
			RPIF11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising edge event pending for configurable line
			RPIF12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising edge event pending for configurable line
			RPIF13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising edge event pending for configurable line
			RPIF14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Rising edge event pending for configurable line
			RPIF15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief EXTI falling edge pending\n          register
		FPR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Falling edge event pending for configurable line
			FPIF0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling edge event pending for configurable line
			FPIF1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling edge event pending for configurable line
			FPIF2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling edge event pending for configurable line
			FPIF3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling edge event pending for configurable line
			FPIF4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling edge event pending for configurable line
			FPIF5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling edge event pending for configurable line
			FPIF6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling edge event pending for configurable line
			FPIF7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling edge event pending for configurable line
			FPIF8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling edge event pending for configurable line
			FPIF9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling edge event pending for configurable line
			FPIF10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling edge event pending for configurable line
			FPIF11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling edge event pending for configurable line
			FPIF12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling edge event pending for configurable line
			FPIF13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling edge event pending for configurable line
			FPIF14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Falling edge event pending for configurable line
			FPIF15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief EXTI external interrupt selection\n          register
		EXTICR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x60, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief GPIO port selection
			EXTI0_7 {
				ec.Access : {0}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief GPIO port selection
			EXTI8_15 {
				ec.Access : {0}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief GPIO port selection
			EXTI16_23 {
				ec.Access : {0}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief GPIO port selection
			EXTI24_31 {
				ec.Access : {0}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief EXTI external interrupt selection\n          register
		EXTICR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x64, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief GPIO port selection
			EXTI0_7 {
				ec.Access : {0}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief GPIO port selection
			EXTI8_15 {
				ec.Access : {0}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief GPIO port selection
			EXTI16_23 {
				ec.Access : {0}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief GPIO port selection
			EXTI24_31 {
				ec.Access : {0}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief EXTI external interrupt selection\n          register
		EXTICR3 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x68, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief GPIO port selection
			EXTI0_7 {
				ec.Access : {0}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief GPIO port selection
			EXTI8_15 {
				ec.Access : {0}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief GPIO port selection
			EXTI16_23 {
				ec.Access : {0}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief GPIO port selection
			EXTI24_31 {
				ec.Access : {0}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief EXTI external interrupt selection\n          register
		EXTICR4 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x6C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief GPIO port selection
			EXTI0_7 {
				ec.Access : {0}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief GPIO port selection
			EXTI8_15 {
				ec.Access : {0}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief GPIO port selection
			EXTI16_23 {
				ec.Access : {0}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief GPIO port selection
			EXTI24_31 {
				ec.Access : {0}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief EXTI CPU wakeup with interrupt mask\n          register
		IMR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x80, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief CPU wakeup with interrupt mask on event\n              input
			IM0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with interrupt mask on event\n              input
			IM1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with interrupt mask on event\n              input
			IM2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with interrupt mask on event\n              input
			IM3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with interrupt mask on event\n              input
			IM4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with interrupt mask on event\n              input
			IM5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with interrupt mask on event\n              input
			IM6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with interrupt mask on event\n              input
			IM7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with interrupt mask on event\n              input
			IM8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with interrupt mask on event\n              input
			IM9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with interrupt mask on event\n              input
			IM10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with interrupt mask on event\n              input
			IM11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with interrupt mask on event\n              input
			IM12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with interrupt mask on event\n              input
			IM13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with interrupt mask on event\n              input
			IM14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with interrupt mask on event\n              input
			IM15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with interrupt mask on event\n              input
			IM19 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with interrupt mask on event\n              input
			IM21 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with interrupt mask on event\n              input
			IM22 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with interrupt mask on event\n              input
			IM23 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with interrupt mask on event\n              input
			IM24 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with interrupt mask on event\n              input
			IM25 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {25, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with interrupt mask on event\n              input
			IM26 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with interrupt mask on event\n              input
			IM31 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {31, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief EXTI CPU wakeup with event mask\n          register
		EMR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x84, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief CPU wakeup with event mask on event\n              input
			EM0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with event mask on event\n              input
			EM1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with event mask on event\n              input
			EM2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with event mask on event\n              input
			EM3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with event mask on event\n              input
			EM4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with event mask on event\n              input
			EM5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with event mask on event\n              input
			EM6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with event mask on event\n              input
			EM7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with event mask on event\n              input
			EM8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with event mask on event\n              input
			EM9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with event mask on event\n              input
			EM10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with event mask on event\n              input
			EM11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with event mask on event\n              input
			EM12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with event mask on event\n              input
			EM13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with event mask on event\n              input
			EM14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with event mask on event\n              input
			EM15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with event mask on event\n              input
			EM19 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with event mask on event\n              input
			EM21 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with event mask on event\n              input
			EM23 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with event mask on event\n              input
			EM25 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {25, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with event mask on event\n              input
			EM26 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CPU wakeup with event mask on event\n              input
			EM31 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {31, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief General purpose timers
	TIM16 {
		ec.Peripheral : {0}
		ec.Size : {size : {0x400, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x40014400, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief control register 1
		CR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Counter enable
			CEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Update disable
			UDIS {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Update request source
			URS {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief One-pulse mode
			OPM {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Auto-reload preload enable
			ARPE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clock division
			CKD {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief UIF status bit remapping
			UIFREMAP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief control register 2
		CR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x4, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Output Idle state 1
			OIS1N {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Idle state 1
			OIS1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare DMA\n              selection
			CCDS {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare control update\n              selection
			CCUS {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare preloaded\n              control
			CCPC {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA/Interrupt enable register
		DIER {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xC, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief COM DMA request enable
			COMDE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 DMA request\n              enable
			CC1DE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Update DMA request enable
			UDE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break interrupt enable
			BIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief COM interrupt enable
			COMIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 interrupt\n              enable
			CC1IE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Update interrupt enable
			UIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief status register
		SR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare 1 overcapture\n              flag
			CC1OF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break interrupt flag
			BIF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief COM interrupt flag
			COMIF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare 1 interrupt\n              flag
			CC1IF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Update interrupt flag
			UIF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief event generation register
		EGR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x14, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Break generation
			BG {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare control update\n              generation
			COMG {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare 1\n              generation
			CC1G {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Update generation
			UG {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief capture/compare mode register (output\n          mode)
		CCMR1_Output {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Output Compare 1 mode
			OC1M_2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Compare 1 mode
			OC1M {
				ec.Access : {0}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Compare 1 preload\n              enable
			OC1PE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Compare 1 fast\n              enable
			OC1FE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1\n              selection
			CC1S {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief capture/compare mode register 1 (input\n          mode)
		CCMR1_Input {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Input capture 1 filter
			IC1F {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Input capture 1 prescaler
			IC1PSC {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1\n              selection
			CC1S {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief capture/compare enable\n          register
		CCER {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x20, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare 1 output\n              Polarity
			CC1NP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 complementary output\n              enable
			CC1NE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 output\n              Polarity
			CC1P {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 output\n              enable
			CC1E {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief counter
		CNT {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x24, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief counter value
			CNT {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief UIF Copy
			UIFCPY {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {31, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief prescaler
		PSC {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x28, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Prescaler value
			PSC {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief auto-reload register
		ARR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x2C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Auto-reload value
			ARR {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief repetition counter register
		RCR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x30, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Repetition counter value
			REP {
				ec.Access : {0}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief capture/compare register 1
		CCR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x34, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare 1 value
			CCR1 {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief break and dead-time register
		BDTR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x44, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Dead-time generator setup
			DTG {
				ec.Access : {0}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Lock configuration
			LOCK {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Off-state selection for Idle\n              mode
			OSSI {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Off-state selection for Run\n              mode
			OSSR {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break enable
			BKE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break polarity
			BKP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Automatic output enable
			AOE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Main output enable
			MOE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break filter
			BKF {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break Disarm
			BKDSRM {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break Bidirectional
			BKBID {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA control register
		DCR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x48, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief DMA burst length
			DBL {
				ec.Access : {0}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA base address
			DBA {
				ec.Access : {0}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA address for full transfer
		DMAR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x4C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief DMA register for burst\n              accesses
			DMAB {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM17 option register 1
		AF1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x60, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief BRK BKIN input enable
			BKINE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief BRK COMP1 enable
			BKCMP1E {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief BRK COMP2 enable
			BKCMP2E {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief BRK DFSDM_BREAK1 enable
			BKDFBK1E {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief BRK BKIN input polarity
			BKINP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief BRK COMP1 input polarity
			BKCMP1P {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief BRK COMP2 input polarit
			BKCMP2P {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief input selection register
		TISEL {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x68, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief selects input
			TI1SEL {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief General purpose timers
	TIM17 {
		ec.Peripheral : {0}
		ec.Size : {size : {0x400, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x40014800, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief control register 1
		CR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Counter enable
			CEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Update disable
			UDIS {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Update request source
			URS {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief One-pulse mode
			OPM {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Auto-reload preload enable
			ARPE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clock division
			CKD {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief UIF status bit remapping
			UIFREMAP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief control register 2
		CR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x4, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Output Idle state 1
			OIS1N {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Idle state 1
			OIS1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare DMA\n              selection
			CCDS {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare control update\n              selection
			CCUS {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare preloaded\n              control
			CCPC {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA/Interrupt enable register
		DIER {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xC, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief COM DMA request enable
			COMDE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 DMA request\n              enable
			CC1DE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Update DMA request enable
			UDE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break interrupt enable
			BIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief COM interrupt enable
			COMIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 interrupt\n              enable
			CC1IE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Update interrupt enable
			UIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief status register
		SR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare 1 overcapture\n              flag
			CC1OF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break interrupt flag
			BIF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief COM interrupt flag
			COMIF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare 1 interrupt\n              flag
			CC1IF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Update interrupt flag
			UIF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief event generation register
		EGR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x14, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Break generation
			BG {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare control update\n              generation
			COMG {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare 1\n              generation
			CC1G {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Update generation
			UG {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief capture/compare mode register (output\n          mode)
		CCMR1_Output {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Output Compare 1 mode
			OC1M_2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Compare 1 mode
			OC1M {
				ec.Access : {0}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Compare 1 preload\n              enable
			OC1PE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Compare 1 fast\n              enable
			OC1FE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1\n              selection
			CC1S {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief capture/compare mode register 1 (input\n          mode)
		CCMR1_Input {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Input capture 1 filter
			IC1F {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Input capture 1 prescaler
			IC1PSC {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1\n              selection
			CC1S {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief capture/compare enable\n          register
		CCER {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x20, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare 1 output\n              Polarity
			CC1NP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 complementary output\n              enable
			CC1NE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 output\n              Polarity
			CC1P {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 output\n              enable
			CC1E {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief counter
		CNT {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x24, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief counter value
			CNT {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief UIF Copy
			UIFCPY {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {31, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief prescaler
		PSC {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x28, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Prescaler value
			PSC {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief auto-reload register
		ARR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x2C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Auto-reload value
			ARR {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief repetition counter register
		RCR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x30, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Repetition counter value
			REP {
				ec.Access : {0}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief capture/compare register 1
		CCR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x34, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare 1 value
			CCR1 {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief break and dead-time register
		BDTR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x44, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Dead-time generator setup
			DTG {
				ec.Access : {0}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Lock configuration
			LOCK {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Off-state selection for Idle\n              mode
			OSSI {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Off-state selection for Run\n              mode
			OSSR {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break enable
			BKE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break polarity
			BKP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Automatic output enable
			AOE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Main output enable
			MOE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break filter
			BKF {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break Disarm
			BKDSRM {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break Bidirectional
			BKBID {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA control register
		DCR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x48, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief DMA burst length
			DBL {
				ec.Access : {0}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA base address
			DBA {
				ec.Access : {0}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA address for full transfer
		DMAR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x4C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief DMA register for burst\n              accesses
			DMAB {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM17 option register 1
		AF1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x60, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief BRK BKIN input enable
			BKINE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief BRK COMP1 enable
			BKCMP1E {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief BRK COMP2 enable
			BKCMP2E {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief BRK DFSDM_BREAK1 enable
			BKDFBK1E {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief BRK BKIN input polarity
			BKINP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief BRK COMP1 input polarity
			BKCMP1P {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief BRK COMP2 input polarit
			BKCMP2P {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief input selection register
		TISEL {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x68, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief selects input
			TI1SEL {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief Universal synchronous asynchronous receiver\n      transmitter
	USART1 {
		ec.Peripheral : {0}
		ec.Size : {size : {0x400, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x40013800, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief Control register 1
		CR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief RXFIFO Full interrupt\n              enable
			RXFFIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {31, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TXFIFO empty interrupt\n              enable
			TXFEIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief FIFO mode enable
			FIFOEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {29, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Word length
			M1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief End of Block interrupt\n              enable
			EOBIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {27, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receiver timeout interrupt\n              enable
			RTOIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DEAT
			DEAT {
				ec.Access : {0}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DEDT
			DEDT {
				ec.Access : {0}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Oversampling mode
			OVER8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Character match interrupt\n              enable
			CMIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Mute mode enable
			MME {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Word length
			M0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receiver wakeup method
			WAKE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Parity control enable
			PCE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Parity selection
			PS {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief PE interrupt enable
			PEIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief interrupt enable
			TXEIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmission complete interrupt\n              enable
			TCIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RXNE interrupt enable
			RXNEIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief IDLE interrupt enable
			IDLEIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmitter enable
			TE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receiver enable
			RE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief USART enable in Stop mode
			UESM {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief USART enable
			UE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Control register 2
		CR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x4, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Address of the USART node
			ADD4_7 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Address of the USART node
			ADD0_3 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receiver timeout enable
			RTOEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Auto baud rate mode
			ABRMOD {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Auto baud rate enable
			ABREN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Most significant bit first
			MSBFIRST {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Binary data inversion
			TAINV {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TX pin active level\n              inversion
			TXINV {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RX pin active level\n              inversion
			RXINV {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Swap TX/RX pins
			SWAP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief LIN mode enable
			LINEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief STOP bits
			STOP {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clock enable
			CLKEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clock polarity
			CPOL {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clock phase
			CPHA {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Last bit clock pulse
			LBCL {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief LIN break detection interrupt\n              enable
			LBDIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief LIN break detection length
			LBDL {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief 7-bit Address Detection/4-bit Address\n              Detection
			ADDM7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief When the DSI_NSS bit is set, the NSS pin\n              input will be ignored
			DIS_NSS {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Synchronous Slave mode\n              enable
			SLVEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Control register 3
		CR3 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x8, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief TXFIFO threshold\n              configuration
			TXFTCFG {
				ec.Access : {0}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {29, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RXFIFO threshold interrupt\n              enable
			RXFTIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receive FIFO threshold\n              configuration
			RXFTCFG {
				ec.Access : {0}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {25, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Tr Complete before guard time, interrupt\n              enable
			TCBGTIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief threshold interrupt enable
			TXFTIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Wakeup from Stop mode interrupt\n              enable
			WUFIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Wakeup from Stop mode interrupt flag\n              selection
			WUS {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Smartcard auto-retry count
			SCARCNT {
				ec.Access : {0}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Driver enable polarity\n              selection
			DEP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Driver enable mode
			DEM {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA Disable on Reception\n              Error
			DDRE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Overrun Disable
			OVRDIS {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief One sample bit method\n              enable
			ONEBIT {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CTS interrupt enable
			CTSIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CTS enable
			CTSE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RTS enable
			RTSE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA enable transmitter
			DMAT {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA enable receiver
			DMAR {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Smartcard mode enable
			SCEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Smartcard NACK enable
			NACK {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Half-duplex selection
			HDSEL {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Ir low-power
			IRLP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Ir mode enable
			IREN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Error interrupt enable
			EIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Baud rate register
		BRR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xC, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief BRR_4_15
			BRR_4_15 {
				ec.Access : {0}
				ec.Size : {size : {12, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief BRR_0_3
			BRR_0_3 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Guard time and prescaler\n          register
		GTPR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Guard time value
			GT {
				ec.Access : {0}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Prescaler value
			PSC {
				ec.Access : {0}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Receiver timeout register
		RTOR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x14, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Block Length
			BLEN {
				ec.Access : {0}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receiver timeout value
			RTO {
				ec.Access : {0}
				ec.Size : {size : {24, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Request register
		RQR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Transmit data flush\n              request
			TXFRQ {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receive data flush request
			RXFRQ {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Mute mode request
			MMRQ {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Send break request
			SBKRQ {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Auto baud rate request
			ABRRQ {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Interrupt & status\n          register
		ISR {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x1C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief TXFIFO threshold flag
			TXFT {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {27, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RXFIFO threshold flag
			RXFT {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmission complete before guard time\n              flag
			TCBGT {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {25, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RXFIFO Full
			RXFF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TXFIFO Empty
			TXFE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief REACK
			REACK {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TEACK
			TEACK {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief WUF
			WUF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RWU
			RWU {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SBKF
			SBKF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CMF
			CMF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief BUSY
			BUSY {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief ABRF
			ABRF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief ABRE
			ABRE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SPI slave underrun error\n              flag
			UDR {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief EOBF
			EOBF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RTOF
			RTOF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CTS
			CTS {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CTSIF
			CTSIF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief LBDF
			LBDF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TXE
			TXE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TC
			TC {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RXNE
			RXNE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief IDLE
			IDLE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief ORE
			ORE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief NF
			NF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief FE
			FE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief PE
			PE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Interrupt flag clear register
		ICR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x20, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Wakeup from Stop mode clear\n              flag
			WUCF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Character match clear flag
			CMCF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SPI slave underrun clear\n              flag
			UDRCF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief End of block clear flag
			EOBCF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receiver timeout clear\n              flag
			RTOCF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CTS clear flag
			CTSCF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief LIN break detection clear\n              flag
			LBDCF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmission complete before Guard time\n              clear flag
			TCBGTCF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmission complete clear\n              flag
			TCCF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TXFIFO empty clear flag
			TXFECF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Idle line detected clear\n              flag
			IDLECF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Overrun error clear flag
			ORECF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Noise detected clear flag
			NCF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Framing error clear flag
			FECF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Parity error clear flag
			PECF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Receive data register
		RDR {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x24, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Receive data value
			RDR {
				ec.Access : {0}
				ec.Size : {size : {9, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Transmit data register
		TDR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x28, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Transmit data value
			TDR {
				ec.Access : {0}
				ec.Size : {size : {9, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Prescaler register
		PRESC {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x2C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Clock prescaler
			PRESCALER {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief Universal synchronous asynchronous receiver\n      transmitter
	USART2 {
		ec.Peripheral : {0}
		ec.Size : {size : {0x400, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x40004400, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief Control register 1
		CR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief RXFIFO Full interrupt\n              enable
			RXFFIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {31, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TXFIFO empty interrupt\n              enable
			TXFEIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief FIFO mode enable
			FIFOEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {29, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Word length
			M1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief End of Block interrupt\n              enable
			EOBIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {27, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receiver timeout interrupt\n              enable
			RTOIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DEAT
			DEAT {
				ec.Access : {0}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DEDT
			DEDT {
				ec.Access : {0}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Oversampling mode
			OVER8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Character match interrupt\n              enable
			CMIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Mute mode enable
			MME {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Word length
			M0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receiver wakeup method
			WAKE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Parity control enable
			PCE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Parity selection
			PS {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief PE interrupt enable
			PEIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief interrupt enable
			TXEIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmission complete interrupt\n              enable
			TCIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RXNE interrupt enable
			RXNEIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief IDLE interrupt enable
			IDLEIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmitter enable
			TE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receiver enable
			RE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief USART enable in Stop mode
			UESM {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief USART enable
			UE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Control register 2
		CR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x4, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Address of the USART node
			ADD4_7 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Address of the USART node
			ADD0_3 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receiver timeout enable
			RTOEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Auto baud rate mode
			ABRMOD {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Auto baud rate enable
			ABREN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Most significant bit first
			MSBFIRST {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Binary data inversion
			TAINV {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TX pin active level\n              inversion
			TXINV {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RX pin active level\n              inversion
			RXINV {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Swap TX/RX pins
			SWAP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief LIN mode enable
			LINEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief STOP bits
			STOP {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clock enable
			CLKEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clock polarity
			CPOL {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clock phase
			CPHA {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Last bit clock pulse
			LBCL {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief LIN break detection interrupt\n              enable
			LBDIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief LIN break detection length
			LBDL {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief 7-bit Address Detection/4-bit Address\n              Detection
			ADDM7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief When the DSI_NSS bit is set, the NSS pin\n              input will be ignored
			DIS_NSS {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Synchronous Slave mode\n              enable
			SLVEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Control register 3
		CR3 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x8, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief TXFIFO threshold\n              configuration
			TXFTCFG {
				ec.Access : {0}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {29, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RXFIFO threshold interrupt\n              enable
			RXFTIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receive FIFO threshold\n              configuration
			RXFTCFG {
				ec.Access : {0}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {25, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Tr Complete before guard time, interrupt\n              enable
			TCBGTIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief threshold interrupt enable
			TXFTIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Wakeup from Stop mode interrupt\n              enable
			WUFIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Wakeup from Stop mode interrupt flag\n              selection
			WUS {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Smartcard auto-retry count
			SCARCNT {
				ec.Access : {0}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Driver enable polarity\n              selection
			DEP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Driver enable mode
			DEM {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA Disable on Reception\n              Error
			DDRE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Overrun Disable
			OVRDIS {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief One sample bit method\n              enable
			ONEBIT {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CTS interrupt enable
			CTSIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CTS enable
			CTSE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RTS enable
			RTSE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA enable transmitter
			DMAT {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA enable receiver
			DMAR {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Smartcard mode enable
			SCEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Smartcard NACK enable
			NACK {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Half-duplex selection
			HDSEL {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Ir low-power
			IRLP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Ir mode enable
			IREN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Error interrupt enable
			EIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Baud rate register
		BRR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xC, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief BRR_4_15
			BRR_4_15 {
				ec.Access : {0}
				ec.Size : {size : {12, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief BRR_0_3
			BRR_0_3 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Guard time and prescaler\n          register
		GTPR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Guard time value
			GT {
				ec.Access : {0}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Prescaler value
			PSC {
				ec.Access : {0}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Receiver timeout register
		RTOR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x14, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Block Length
			BLEN {
				ec.Access : {0}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receiver timeout value
			RTO {
				ec.Access : {0}
				ec.Size : {size : {24, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Request register
		RQR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Transmit data flush\n              request
			TXFRQ {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receive data flush request
			RXFRQ {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Mute mode request
			MMRQ {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Send break request
			SBKRQ {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Auto baud rate request
			ABRRQ {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Interrupt & status\n          register
		ISR {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x1C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief TXFIFO threshold flag
			TXFT {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {27, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RXFIFO threshold flag
			RXFT {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmission complete before guard time\n              flag
			TCBGT {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {25, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RXFIFO Full
			RXFF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TXFIFO Empty
			TXFE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief REACK
			REACK {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TEACK
			TEACK {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief WUF
			WUF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RWU
			RWU {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SBKF
			SBKF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CMF
			CMF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief BUSY
			BUSY {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief ABRF
			ABRF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief ABRE
			ABRE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SPI slave underrun error\n              flag
			UDR {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief EOBF
			EOBF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RTOF
			RTOF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CTS
			CTS {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CTSIF
			CTSIF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief LBDF
			LBDF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TXE
			TXE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TC
			TC {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RXNE
			RXNE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief IDLE
			IDLE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief ORE
			ORE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief NF
			NF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief FE
			FE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief PE
			PE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Interrupt flag clear register
		ICR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x20, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Wakeup from Stop mode clear\n              flag
			WUCF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Character match clear flag
			CMCF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SPI slave underrun clear\n              flag
			UDRCF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief End of block clear flag
			EOBCF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receiver timeout clear\n              flag
			RTOCF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CTS clear flag
			CTSCF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief LIN break detection clear\n              flag
			LBDCF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmission complete before Guard time\n              clear flag
			TCBGTCF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmission complete clear\n              flag
			TCCF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TXFIFO empty clear flag
			TXFECF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Idle line detected clear\n              flag
			IDLECF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Overrun error clear flag
			ORECF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Noise detected clear flag
			NCF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Framing error clear flag
			FECF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Parity error clear flag
			PECF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Receive data register
		RDR {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x24, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Receive data value
			RDR {
				ec.Access : {0}
				ec.Size : {size : {9, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Transmit data register
		TDR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x28, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Transmit data value
			TDR {
				ec.Access : {0}
				ec.Size : {size : {9, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Prescaler register
		PRESC {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x2C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Clock prescaler
			PRESCALER {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief Serial peripheral interface/Inter-IC\n      sound
	SPI1 {
		ec.Peripheral : {0}
		ec.Size : {size : {0x400, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x40013000, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief control register 1
		CR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Bidirectional data mode\n              enable
			BIDIMODE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output enable in bidirectional\n              mode
			BIDIOE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Hardware CRC calculation\n              enable
			CRCEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CRC transfer next
			CRCNEXT {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Data frame format
			DFF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receive only
			RXONLY {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Software slave management
			SSM {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Internal slave select
			SSI {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Frame format
			LSBFIRST {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SPI enable
			SPE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Baud rate control
			BR {
				ec.Access : {0}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Master selection
			MSTR {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clock polarity
			CPOL {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clock phase
			CPHA {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief control register 2
		CR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x4, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Rx buffer DMA enable
			RXDMAEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Tx buffer DMA enable
			TXDMAEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SS output enable
			SSOE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief NSS pulse management
			NSSP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Frame format
			FRF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Error interrupt enable
			ERRIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RX buffer not empty interrupt\n              enable
			RXNEIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Tx buffer empty interrupt\n              enable
			TXEIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Data size
			DS {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief FIFO reception threshold
			FRXTH {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Last DMA transfer for\n              reception
			LDMA_RX {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Last DMA transfer for\n              transmission
			LDMA_TX {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief status register
		SR {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x8, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Receive buffer not empty
			RXNE {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmit buffer empty
			TXE {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel side
			CHSIDE {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Underrun flag
			UDR {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CRC error flag
			CRCERR {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Mode fault
			MODF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Overrun flag
			OVR {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Busy flag
			BSY {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TI frame format error
			TIFRFE {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief FIFO reception level
			FRLVL {
				ec.Access : {R}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief FIFO transmission level
			FTLVL {
				ec.Access : {R}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief data register
		DR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xC, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Data register
			DR {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief CRC polynomial register
		CRCPR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief CRC polynomial register
			CRCPOLY {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RX CRC register
		RXCRCR {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x14, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Rx CRC register
			RxCRC {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TX CRC register
		TXCRCR {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Tx CRC register
			TxCRC {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief configuration register
		I2SCFGR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x1C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Channel length (number of bits per audio\n              channel)
			CHLEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Data length to be\n              transferred
			DATLEN {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Inactive state clock\n              polarity
			CKPOL {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief standard selection
			I2SSTD {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief PCM frame synchronization
			PCMSYNC {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I2S configuration mode
			I2SCFG {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I2S enable
			SE2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I2S mode selection
			I2SMOD {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief prescaler register
		I2SPR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x20, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief linear prescaler
			I2SDIV {
				ec.Access : {0}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Odd factor for the\n              prescaler
			ODD {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Master clock output enable
			MCKOE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief Serial peripheral interface/Inter-IC\n      sound
	SPI2 {
		ec.Peripheral : {0}
		ec.Size : {size : {0x400, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x40003800, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief control register 1
		CR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Bidirectional data mode\n              enable
			BIDIMODE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output enable in bidirectional\n              mode
			BIDIOE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Hardware CRC calculation\n              enable
			CRCEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CRC transfer next
			CRCNEXT {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Data frame format
			DFF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receive only
			RXONLY {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Software slave management
			SSM {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Internal slave select
			SSI {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Frame format
			LSBFIRST {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SPI enable
			SPE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Baud rate control
			BR {
				ec.Access : {0}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Master selection
			MSTR {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clock polarity
			CPOL {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clock phase
			CPHA {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief control register 2
		CR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x4, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Rx buffer DMA enable
			RXDMAEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Tx buffer DMA enable
			TXDMAEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SS output enable
			SSOE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief NSS pulse management
			NSSP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Frame format
			FRF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Error interrupt enable
			ERRIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RX buffer not empty interrupt\n              enable
			RXNEIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Tx buffer empty interrupt\n              enable
			TXEIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Data size
			DS {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief FIFO reception threshold
			FRXTH {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Last DMA transfer for\n              reception
			LDMA_RX {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Last DMA transfer for\n              transmission
			LDMA_TX {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief status register
		SR {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x8, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Receive buffer not empty
			RXNE {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmit buffer empty
			TXE {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Channel side
			CHSIDE {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Underrun flag
			UDR {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief CRC error flag
			CRCERR {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Mode fault
			MODF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Overrun flag
			OVR {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Busy flag
			BSY {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TI frame format error
			TIFRFE {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief FIFO reception level
			FRLVL {
				ec.Access : {R}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief FIFO transmission level
			FTLVL {
				ec.Access : {R}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief data register
		DR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xC, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Data register
			DR {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief CRC polynomial register
		CRCPR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief CRC polynomial register
			CRCPOLY {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RX CRC register
		RXCRCR {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x14, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Rx CRC register
			RxCRC {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TX CRC register
		TXCRCR {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Tx CRC register
			TxCRC {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief configuration register
		I2SCFGR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x1C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Channel length (number of bits per audio\n              channel)
			CHLEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Data length to be\n              transferred
			DATLEN {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Inactive state clock\n              polarity
			CKPOL {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief standard selection
			I2SSTD {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief PCM frame synchronization
			PCMSYNC {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I2S configuration mode
			I2SCFG {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I2S enable
			SE2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I2S mode selection
			I2SMOD {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief prescaler register
		I2SPR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x20, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief linear prescaler
			I2SDIV {
				ec.Access : {0}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Odd factor for the\n              prescaler
			ODD {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Master clock output enable
			MCKOE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief Advanced-timers
	TIM1 {
		ec.Peripheral : {0}
		ec.Size : {size : {0x400, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x40012C00, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief control register 1
		CR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Counter enable
			CEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief One-pulse mode
			OPM {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Update disable
			UDIS {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Update request source
			URS {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Direction
			DIR {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Center-aligned mode\n              selection
			CMS {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Auto-reload preload enable
			ARPE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clock division
			CKD {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief UIF status bit remapping
			UIFREMAP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief control register 2
		CR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x4, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Master mode selection 2
			MMS2 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Idle state 6 (OC6\n              output)
			OIS6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Idle state 5 (OC5\n              output)
			OIS5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Idle state 4
			OIS4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Idle state 3
			OIS3N {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Idle state 3
			OIS3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Idle state 2
			OIS2N {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Idle state 2
			OIS2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Idle state 1
			OIS1N {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Idle state 1
			OIS1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TI1 selection
			TI1S {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Master mode selection
			MMS {
				ec.Access : {0}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare DMA\n              selection
			CCDS {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare control update\n              selection
			CCUS {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare preloaded\n              control
			CCPC {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief slave mode control register
		SMCR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x8, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Slave mode selection
			SMS {
				ec.Access : {0}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief OCREF clear selection
			OCCS {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Trigger selection
			TS_4 {
				ec.Access : {0}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Master/Slave mode
			MSM {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief External trigger filter
			ETF {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief External trigger prescaler
			ETPS {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief External clock enable
			ECE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief External trigger polarity
			ETP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Slave mode selection - bit\n              3
			SMS_3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Trigger selection
			TS {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA/Interrupt enable register
		DIER {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xC, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Update interrupt enable
			UIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 interrupt\n              enable
			CC1IE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 2 interrupt\n              enable
			CC2IE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 3 interrupt\n              enable
			CC3IE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 4 interrupt\n              enable
			CC4IE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief COM interrupt enable
			COMIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Trigger interrupt enable
			TIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break interrupt enable
			BIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Update DMA request enable
			UDE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 DMA request\n              enable
			CC1DE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 2 DMA request\n              enable
			CC2DE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 3 DMA request\n              enable
			CC3DE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 4 DMA request\n              enable
			CC4DE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief COM DMA request enable
			COMDE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Trigger DMA request enable
			TDE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief status register
		SR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Update interrupt flag
			UIF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare 1 interrupt\n              flag
			CC1IF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 2 interrupt\n              flag
			CC2IF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 3 interrupt\n              flag
			CC3IF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 4 interrupt\n              flag
			CC4IF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief COM interrupt flag
			COMIF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Trigger interrupt flag
			TIF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break interrupt flag
			BIF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break 2 interrupt flag
			B2IF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 overcapture\n              flag
			CC1OF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare 2 overcapture\n              flag
			CC2OF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 3 overcapture\n              flag
			CC3OF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 4 overcapture\n              flag
			CC4OF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief System Break interrupt\n              flag
			SBIF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Compare 5 interrupt flag
			CC5IF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Compare 6 interrupt flag
			CC6IF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief event generation register
		EGR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x14, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Update generation
			UG {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare 1\n              generation
			CC1G {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare 2\n              generation
			CC2G {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare 3\n              generation
			CC3G {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare 4\n              generation
			CC4G {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare control update\n              generation
			COMG {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Trigger generation
			TG {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break generation
			BG {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break 2 generation
			B2G {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief capture/compare mode register 1 (output\n          mode)
		CCMR1_Output {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare 1\n              selection
			CC1S {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Compare 1 fast\n              enable
			OC1FE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Compare 1 preload\n              enable
			OC1PE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Compare 1 mode
			OC1M {
				ec.Access : {0}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Compare 1 clear\n              enable
			OC1CE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 2\n              selection
			CC2S {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Compare 2 fast\n              enable
			OC2FE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Compare 2 preload\n              enable
			OC2PE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Compare 2 mode
			OC2M {
				ec.Access : {0}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Compare 2 clear\n              enable
			OC2CE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Compare 1 mode - bit\n              3
			OC1M_3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Compare 2 mode - bit\n              3
			OC2M_3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief capture/compare mode register 1 (output\n          mode)
		CCMR1_Input {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare 1\n              selection
			CC1S {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Compare 1 fast\n              enable
			OC1FE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Compare 1 preload\n              enable
			OC1PE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Compare 1 mode
			OC1M {
				ec.Access : {0}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Compare 1 clear\n              enable
			OC1CE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 2\n              selection
			CC2S {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Compare 2 fast\n              enable
			OC2FE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Compare 2 preload\n              enable
			OC2PE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Compare 2 mode
			OC2M {
				ec.Access : {0}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Compare 2 clear\n              enable
			OC2CE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief capture/compare mode register 2 (output\n          mode)
		CCMR2_Output {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x1C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare 3\n              selection
			CC3S {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 3 fast\n              enable
			OC3FE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 3 preload\n              enable
			OC3PE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 3 mode
			OC3M {
				ec.Access : {0}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 3 clear\n              enable
			OC3CE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 4\n              selection
			CC4S {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 4 fast\n              enable
			OC4FE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 4 preload\n              enable
			OC4PE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 4 mode
			OC4M {
				ec.Access : {0}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 4 clear\n              enable
			OC4CE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Compare 3 mode - bit\n              3
			OC3M_3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Compare 4 mode - bit\n              3
			OC4M_3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief capture/compare mode register 2 (output\n          mode)
		CCMR2_Input {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x1C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare 3\n              selection
			CC3S {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 3 fast\n              enable
			OC3FE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 3 preload\n              enable
			OC3PE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 3 mode
			OC3M {
				ec.Access : {0}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 3 clear\n              enable
			OC3CE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 4\n              selection
			CC4S {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 4 fast\n              enable
			OC4FE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 4 preload\n              enable
			OC4PE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 4 mode
			OC4M {
				ec.Access : {0}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 4 clear\n              enable
			OC4CE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief capture/compare enable\n          register
		CCER {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x20, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare 1 output\n              enable
			CC1E {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 output\n              Polarity
			CC1P {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 complementary output\n              enable
			CC1NE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 output\n              Polarity
			CC1NP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 2 output\n              enable
			CC2E {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 2 output\n              Polarity
			CC2P {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 2 complementary output\n              enable
			CC2NE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 2 output\n              Polarity
			CC2NP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 3 output\n              enable
			CC3E {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 3 output\n              Polarity
			CC3P {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 3 complementary output\n              enable
			CC3NE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 3 output\n              Polarity
			CC3NP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 4 output\n              enable
			CC4E {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 3 output\n              Polarity
			CC4P {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 4 complementary output\n              polarity
			CC4NP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 5 output\n              enable
			CC5E {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 5 output\n              polarity
			CC5P {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 6 output\n              enable
			CC6E {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 6 output\n              polarity
			CC6P {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief counter
		CNT {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x24, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief counter value
			CNT {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief UIF copy
			UIFCPY {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {31, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief prescaler
		PSC {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x28, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Prescaler value
			PSC {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief auto-reload register
		ARR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x2C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Auto-reload value
			ARR {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief repetition counter register
		RCR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x30, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Repetition counter value
			REP {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief capture/compare register 1
		CCR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x34, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare 1 value
			CCR1 {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief capture/compare register 2
		CCR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x38, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare 2 value
			CCR2 {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief capture/compare register 3
		CCR3 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x3C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare value
			CCR3 {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief capture/compare register 4
		CCR4 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x40, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare value
			CCR4 {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief break and dead-time register
		BDTR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x44, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Dead-time generator setup
			DTG {
				ec.Access : {0}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Lock configuration
			LOCK {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Off-state selection for Idle\n              mode
			OSSI {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Off-state selection for Run\n              mode
			OSSR {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break enable
			BKE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break polarity
			BKP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Automatic output enable
			AOE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Main output enable
			MOE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break filter
			BKF {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break 2 filter
			BK2F {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break 2 enable
			BK2E {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break 2 polarity
			BK2P {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {25, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break Disarm
			BKDSRM {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break2 Disarm
			BK2DSRM {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {27, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break Bidirectional
			BKBID {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Break2 bidirectional
			BK2ID {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {29, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA control register
		DCR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x48, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief DMA burst length
			DBL {
				ec.Access : {0}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA base address
			DBA {
				ec.Access : {0}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA address for full transfer
		DMAR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x4C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief DMA register for burst\n              accesses
			DMAB {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief option register 1
		OR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x50, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Ocref_clr source selection
			OCREF_CLR {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief capture/compare mode register 2 (output\n          mode)
		CCMR3_Output {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x54, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Output Compare 6 mode bit\n              3
			OC6M_bit3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Compare 5 mode bit\n              3
			OC5M_bit3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 6 clear\n              enable
			OC6CE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 6 mode
			OC6M {
				ec.Access : {0}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 6 preload\n              enable
			OC6PE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 6 fast\n              enable
			OC6FE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 5 clear\n              enable
			OC5CE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 5 mode
			OC5M {
				ec.Access : {0}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 5 preload\n              enable
			OC5PE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 5 fast\n              enable
			OC5FE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief capture/compare register 4
		CCR5 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x58, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare value
			CCR5 {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Group Channel 5 and Channel\n              1
			GC5C1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {29, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Group Channel 5 and Channel\n              2
			GC5C2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Group Channel 5 and Channel\n              3
			GC5C3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {31, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief capture/compare register 4
		CCR6 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x5C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare value
			CCR6 {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA address for full transfer
		AF1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x60, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief BRK BKIN input enable
			BKINE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief BRK COMP1 enable
			BKCMP1E {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief BRK COMP2 enable
			BKCMP2E {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief BRK BKIN input polarity
			BKINP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief BRK COMP1 input polarity
			BKCMP1P {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief BRK COMP2 input polarity
			BKCMP2P {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief ETR source selection
			ETRSEL {
				ec.Access : {0}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA address for full transfer
		AF2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x64, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief BRK2 BKIN input enable
			BK2INE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief BRK2 COMP1 enable
			BK2CMP1E {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief BRK2 COMP2 enable
			BK2CMP2E {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief BRK2 DFSDM_BREAK0 enable
			BK2DFBK0E {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief BRK2 BKIN input polarity
			BK2INP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief BRK2 COMP1 input polarity
			BK2CMP1P {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief BRK2 COMP2 input polarity
			BK2CMP2P {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM1 timer input selection\n          register
		TISEL {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x68, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief selects TI1[0] to TI1[15]\n              input
			TI1SEL3_0 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief selects TI2[0] to TI2[15]\n              input
			TI2SEL3_0 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief selects TI3[0] to TI3[15]\n              input
			TI3SEL3_0 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief selects TI4[0] to TI4[15]\n              input
			TI4SEL3_0 {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief System configuration controller
	SYSCFG {
		ec.Peripheral : {0}
		ec.Size : {size : {0x100, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x40010000, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief SYSCFG configuration register\n          1
		CFGR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief I2C3_FMP
			I2C3_FMP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Fast Mode Plus (FM+) driving capability\n              activation bits
			I2C_PA10_FMP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Fast Mode Plus (FM+) driving capability\n              activation bits
			I2C_PA9_FMP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief FM+ driving capability activation for\n              I2C2
			I2C2_FMP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief FM+ driving capability activation for\n              I2C1
			I2C1_FMP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I2C_PB9_FMP
			I2C_PB9_FMP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I2C_PB8_FMP
			I2C_PB8_FMP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I2C_PB7_FMP
			I2C_PB7_FMP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Fast Mode Plus (FM+) driving capability\n              activation bits
			I2C_PBx_FMP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Strobe signal bit for\n              UCPD2
			UCPD2_STROBE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Strobe signal bit for\n              UCPD1
			UCPD1_STROBE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I/O analog switch voltage booster\n              enable
			BOOSTEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief IR Modulation Envelope signal\n              selection.
			IR_MOD {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief IR output polarity\n              selection
			IR_POL {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief PA11 and PA12 remapping\n              bit.
			PA12_RMP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief PA11_RMP
			PA11_RMP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Memory mapping selection\n              bits
			MEM_MODE {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief SYSCFG configuration register\n          1
		CFGR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Cortex-M0+ LOCKUP bit enable\n              bit
			LOCKUP_LOCK {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SRAM parity lock bit
			SRAM_PARITY_LOCK {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief ECC error lock bit
			ECC_LOCK {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SRAM parity error flag
			SRAM_PEF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief interrupt line 0 status\n          register
		ITLINE0 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x80, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Window watchdog interrupt pending\n              flag
			WWDG {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief interrupt line 2 status\n          register
		ITLINE2 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x88, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief TAMP
			TAMP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RTC
			RTC {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief interrupt line 3 status\n          register
		ITLINE3 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x8C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief FLASH_ITF
			FLASH_ITF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief FLASH_ECC
			FLASH_ECC {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief interrupt line 4 status\n          register
		ITLINE4 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x90, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief RCC
			RCC {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief interrupt line 5 status\n          register
		ITLINE5 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x94, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief EXTI0
			EXTI0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief EXTI1
			EXTI1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief interrupt line 6 status\n          register
		ITLINE6 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x98, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief EXTI2
			EXTI2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief EXTI3
			EXTI3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief interrupt line 7 status\n          register
		ITLINE7 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x9C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief EXTI4
			EXTI4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief EXTI5
			EXTI5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief EXTI6
			EXTI6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief EXTI7
			EXTI7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief EXTI8
			EXTI8 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief EXTI9
			EXTI9 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief EXTI10
			EXTI10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief EXTI11
			EXTI11 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief EXTI12
			EXTI12 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief EXTI13
			EXTI13 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief EXTI14
			EXTI14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief EXTI15
			EXTI15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief interrupt line 8 status\n          register
		ITLINE8 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xA0, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief USB
			USB {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief interrupt line 9 status\n          register
		ITLINE9 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xA4, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief DMA1_CH1
			DMA1_CH1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief interrupt line 10 status\n          register
		ITLINE10 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xA8, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief DMA1_CH1
			DMA1_CH2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA1_CH3
			DMA1_CH3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief interrupt line 11 status\n          register
		ITLINE11 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xAC, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief DMAMUX
			DMAMUX {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA1_CH4
			DMA1_CH4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA1_CH5
			DMA1_CH5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA1_CH6
			DMA1_CH6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA1_CH7
			DMA1_CH7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA2_CH1
			DMA2_CH1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA2_CH2
			DMA2_CH2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA2_CH3
			DMA2_CH3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA2_CH4
			DMA2_CH4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA2_CH5
			DMA2_CH5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief interrupt line 12 status\n          register
		ITLINE12 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xB0, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief ADC
			ADC {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief interrupt line 13 status\n          register
		ITLINE13 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xB4, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief TIM1_CCU
			TIM1_CCU {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TIM1_TRG
			TIM1_TRG {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TIM1_UPD
			TIM1_UPD {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TIM1_BRK
			TIM1_BRK {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief interrupt line 14 status\n          register
		ITLINE14 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xB8, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief TIM1_CC
			TIM1_CC {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief interrupt line 16 status\n          register
		ITLINE16 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xC0, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief TIM3
			TIM3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TIM4
			TIM4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief interrupt line 17 status\n          register
		ITLINE17 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xC4, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief TIM6
			TIM6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief interrupt line 18 status\n          register
		ITLINE18 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xC8, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief TIM7
			TIM7 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief interrupt line 19 status\n          register
		ITLINE19 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xCC, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief TIM14
			TIM14 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief interrupt line 20 status\n          register
		ITLINE20 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xD0, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief TIM15
			TIM15 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief interrupt line 21 status\n          register
		ITLINE21 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xD4, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief TIM16
			TIM16 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief interrupt line 22 status\n          register
		ITLINE22 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xD8, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief TIM17
			TIM17 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief interrupt line 23 status\n          register
		ITLINE23 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xDC, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief I2C1
			I2C1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief interrupt line 24 status\n          register
		ITLINE24 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xE0, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief I2C2
			I2C2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I2C3
			I2C3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief interrupt line 25 status\n          register
		ITLINE25 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xE4, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief SPI1
			SPI1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief interrupt line 26 status\n          register
		ITLINE26 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xE8, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief SPI2
			SPI2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SPI3
			SPI3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief interrupt line 27 status\n          register
		ITLINE27 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xEC, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief USART1
			USART1 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief interrupt line 28 status\n          register
		ITLINE28 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xF0, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief USART2
			USART2 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief interrupt line 29 status\n          register
		ITLINE29 {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xF4, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief USART3
			USART3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief USART4
			USART4 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief USART5
			USART5 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief USART6
			USART6 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief Tamper and backup registers
	TAMP {
		ec.Peripheral : {0}
		ec.Size : {size : {0x400, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x4000B000, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief TAMP control register 1 
		TAMP_CR1 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Tamper detection on TAMP_IN1 enable
			TAMP1E {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Tamper detection on TAMP_IN2 enable
			TAMP2E {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Tamper detection on TAMP_IN3 enable
			TAMP3E {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Internal tamper 3 enable: LSE monitoring
			ITAMP3E {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Internal tamper 4 enable: HSE monitoring
			ITAMP4E {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Internal tamper 5 enable: RTC calendar overflow
			ITAMP5E {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Internal tamper 6 enable: ST manufacturer readout
			ITAMP6E {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TAMP control register 2 
		TAMP_CR2 {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x4, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Tamper 1 no erase
			TAMP1NOER {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Tamper 2 no erase
			TAMP2NOER {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Tamper 3 no erase
			TAMP3NOER {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Tamper 1 mask\nThe tamper 1 interrupt must not be enabled when TAMP1MSK is set.
			TAMP1MSK {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Tamper 2 mask\nThe tamper 2 interrupt must not be enabled when TAMP2MSK is set.
			TAMP2MSK {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Tamper 3 mask\nThe tamper 3 interrupt must not be enabled when TAMP3MSK is set.
			TAMP3MSK {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Active level for tamper 1 input (active mode disabled)\nIf TAMPFLT = 00 Tamper 1 input rising edge and high level triggers a tamper detection event.\nIf TAMPFLT = 00 Tamper 1 input falling edge and low level triggers a tamper detection event.
			TAMP1TRG {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Active level for tamper 2 input (active mode disabled)\nIf TAMPFLT = 00 Tamper 2 input rising edge and high level triggers a tamper detection event.\nIf TAMPFLT = 00 Tamper 2 input falling edge and low level triggers a tamper detection event.
			TAMP2TRG {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {25, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Active level for tamper 3 input (active mode disabled)\nIf TAMPFLT = 00 Tamper 3 input rising edge and high level triggers a tamper detection event.\nIf TAMPFLT = 00 Tamper 3 input falling edge and low level triggers a tamper detection event.
			TAMP3TRG {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TAMP filter control register 
		TAMP_FLTCR {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xc, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Tamper sampling frequency\nDetermines the frequency at which each of the TAMP_INx inputs are sampled.
			TAMPFREQ {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TAMP_INx filter count\nThese bits determines the number of consecutive samples at the specified level (TAMP*TRG) needed to activate a tamper event. TAMPFLT is valid for each of the TAMP_INx inputs.
			TAMPFLT {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TAMP_INx precharge duration\nThese bit determines the duration of time during which the pull-up/is activated before each sample. TAMPPRCH is valid for each of the TAMP_INx inputs.
			TAMPPRCH {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TAMP_INx pull-up disable\nThis bit determines if each of the TAMPx pins are precharged before each sample.
			TAMPPUDIS {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TAMP interrupt enable register 
		TAMP_IER {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x2c, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Tamper 1 interrupt enable
			TAMP1IE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Tamper 2 interrupt enable
			TAMP2IE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Tamper 3 interrupt enable
			TAMP3IE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Internal tamper 3 interrupt enable: LSE monitoring
			ITAMP3IE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Internal tamper 4 interrupt enable: HSE monitoring
			ITAMP4IE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Internal tamper 5 interrupt enable: RTC calendar overflow
			ITAMP5IE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Internal tamper 6 interrupt enable: ST manufacturer readout
			ITAMP6IE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TAMP status register 
		TAMP_SR {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x30, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief TAMP1 detection flag\nThis flag is set by hardware when a tamper detection event is detected on the TAMP1 input.
			TAMP1F {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TAMP2 detection flag\nThis flag is set by hardware when a tamper detection event is detected on the TAMP2 input.
			TAMP2F {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TAMP3 detection flag\nThis flag is set by hardware when a tamper detection event is detected on the TAMP3 input.
			TAMP3F {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief LSE monitoring tamper detection flag\nThis flag is set by hardware when a tamper detection event is detected on the internal tamper 3.
			ITAMP3F {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief HSE monitoring tamper detection flag\nThis flag is set by hardware when a tamper detection event is detected on the internal tamper 4.
			ITAMP4F {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RTC calendar overflow tamper detection flag\nThis flag is set by hardware when a tamper detection event is detected on the internal tamper 5.
			ITAMP5F {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief ST manufacturer readout tamper detection flag\nThis flag is set by hardware when a tamper detection event is detected on the internal tamper 6.
			ITAMP6F {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TAMP masked interrupt status register 
		TAMP_MISR {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x34, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief TAMP1 interrupt masked flag\nThis flag is set by hardware when the tamper 1 interrupt is raised.
			TAMP1MF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TAMP2 interrupt masked flag\nThis flag is set by hardware when the tamper 2 interrupt is raised.
			TAMP2MF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TAMP3 interrupt masked flag\nThis flag is set by hardware when the tamper 3 interrupt is raised.
			TAMP3MF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief LSE monitoring tamper interrupt masked flag\nThis flag is set by hardware when the internal tamper 3 interrupt is raised.
			ITAMP3MF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief HSE monitoring tamper interrupt masked flag\nThis flag is set by hardware when the internal tamper 4 interrupt is raised.
			ITAMP4MF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RTC calendar overflow tamper interrupt masked flag\nThis flag is set by hardware when the internal tamper 5 interrupt is raised.
			ITAMP5MF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief ST manufacturer readout tamper interrupt masked flag\nThis flag is set by hardware when the internal tamper 6 interrupt is raised.
			ITAMP6MF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TAMP status clear register
		TAMP_SCR {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x3c, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Clear TAMP1 detection flag\nWriting 1 in this bit clears the TAMP1F bit in the TAMP_SR register.
			CTAMP1F {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clear TAMP2 detection flag\nWriting 1 in this bit clears the TAMP2F bit in the TAMP_SR register.
			CTAMP2F {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clear TAMP3 detection flag\nWriting 1 in this bit clears the TAMP3F bit in the TAMP_SR register.
			CTAMP3F {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clear ITAMP3 detection flag\nWriting 1 in this bit clears the ITAMP3F bit in the TAMP_SR register.
			CITAMP3F {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clear ITAMP4 detection flag\nWriting 1 in this bit clears the ITAMP4F bit in the TAMP_SR register.
			CITAMP4F {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clear ITAMP5 detection flag\nWriting 1 in this bit clears the ITAMP5F bit in the TAMP_SR register.
			CITAMP5F {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clear ITAMP6 detection flag\nWriting 1 in this bit clears the ITAMP6F bit in the TAMP_SR register.
			CITAMP6F {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TAMP backup 0 register
		TAMP_BKP0R {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x100, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief The application can write or read data to and from these registers.\nThey are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode.\nIn the defaul
			BKP {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TAMP backup 1 register
		TAMP_BKP1R {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x104, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief The application can write or read data to and from these registers.\nThey are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode.\nIn the defaul
			BKP {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TAMP backup 2 register
		TAMP_BKP2R {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x108, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief The application can write or read data to and from these registers.\nThey are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode.\nIn the defaul
			BKP {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TAMP backup 3 register
		TAMP_BKP3R {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10c, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief The application can write or read data to and from these registers.\nThey are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode.\nIn the defaul
			BKP {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TAMP backup 4 register
		TAMP_BKP4R {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x110, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief The application can write or read data to and from these registers.\nThey are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode.\nIn the defaul
			BKP {
				ec.Access : {R|W}
				ec.Size : {size : {32, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief Inter-integrated circuit
	I2C1 {
		ec.Peripheral : {0}
		ec.Size : {size : {0x400, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x40005400, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief Control register 1
		CR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Peripheral enable
			PE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TX Interrupt enable
			TXIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RX Interrupt enable
			RXIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Address match interrupt enable (slave\n              only)
			ADDRIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Not acknowledge received interrupt\n              enable
			NACKIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief STOP detection Interrupt\n              enable
			STOPIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transfer Complete interrupt\n              enable
			TCIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Error interrupts enable
			ERRIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Digital noise filter
			DNF {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog noise filter OFF
			ANFOFF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA transmission requests\n              enable
			TXDMAEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA reception requests\n              enable
			RXDMAEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Slave byte control
			SBC {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clock stretching disable
			NOSTRETCH {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Wakeup from STOP enable
			WUPEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief General call enable
			GCEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SMBus Host address enable
			SMBHEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SMBus Device Default address\n              enable
			SMBDEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SMBUS alert enable
			ALERTEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief PEC enable
			PECEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Control register 2
		CR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x4, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Packet error checking byte
			PECBYTE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Automatic end mode (master\n              mode)
			AUTOEND {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {25, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief NBYTES reload mode
			RELOAD {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Number of bytes
			NBYTES {
				ec.Access : {0}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief NACK generation (slave\n              mode)
			NACK {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Stop generation (master\n              mode)
			STOP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Start generation
			START {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief 10-bit address header only read\n              direction (master receiver mode)
			HEAD10R {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief 10-bit addressing mode (master\n              mode)
			ADD10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transfer direction (master\n              mode)
			RD_WRN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Slave address bit (master\n              mode)
			SADD {
				ec.Access : {0}
				ec.Size : {size : {10, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Own address register 1
		OAR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x8, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Interface address
			OA1_0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Interface address
			OA1_7_1 {
				ec.Access : {0}
				ec.Size : {size : {7, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Interface address
			OA1_8_9 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Own Address 1 10-bit mode
			OA1MODE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Own Address 1 enable
			OA1EN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Own address register 2
		OAR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xC, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Interface address
			OA2 {
				ec.Access : {0}
				ec.Size : {size : {7, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Own Address 2 masks
			OA2MSK {
				ec.Access : {0}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Own Address 2 enable
			OA2EN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Timing register
		TIMINGR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief SCL low period (master\n              mode)
			SCLL {
				ec.Access : {0}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SCL high period (master\n              mode)
			SCLH {
				ec.Access : {0}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Data hold time
			SDADEL {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Data setup time
			SCLDEL {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Timing prescaler
			PRESC {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Status register 1
		TIMEOUTR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x14, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Bus timeout A
			TIMEOUTA {
				ec.Access : {0}
				ec.Size : {size : {12, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Idle clock timeout\n              detection
			TIDLE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clock timeout enable
			TIMOUTEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Bus timeout B
			TIMEOUTB {
				ec.Access : {0}
				ec.Size : {size : {12, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Extended clock timeout\n              enable
			TEXTEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {31, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Interrupt and Status register
		ISR {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Address match code (Slave\n              mode)
			ADDCODE {
				ec.Access : {R}
				ec.Size : {size : {7, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transfer direction (Slave\n              mode)
			DIR {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Bus busy
			BUSY {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SMBus alert
			ALERT {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Timeout or t_low detection\n              flag
			TIMEOUT {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief PEC Error in reception
			PECERR {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Overrun/Underrun (slave\n              mode)
			OVR {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Arbitration lost
			ARLO {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Bus error
			BERR {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transfer Complete Reload
			TCR {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transfer Complete (master\n              mode)
			TC {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Stop detection flag
			STOPF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Not acknowledge received\n              flag
			NACKF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Address matched (slave\n              mode)
			ADDR {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receive data register not empty\n              (receivers)
			RXNE {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmit interrupt status\n              (transmitters)
			TXIS {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmit data register empty\n              (transmitters)
			TXE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Interrupt clear register
		ICR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x1C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Alert flag clear
			ALERTCF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Timeout detection flag\n              clear
			TIMOUTCF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief PEC Error flag clear
			PECCF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Overrun/Underrun flag\n              clear
			OVRCF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Arbitration lost flag\n              clear
			ARLOCF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Bus error flag clear
			BERRCF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Stop detection flag clear
			STOPCF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Not Acknowledge flag clear
			NACKCF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Address Matched flag clear
			ADDRCF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief PEC register
		PECR {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x20, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Packet error checking\n              register
			PEC {
				ec.Access : {0}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Receive data register
		RXDR {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x24, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief 8-bit receive data
			RXDATA {
				ec.Access : {0}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Transmit data register
		TXDR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x28, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief 8-bit transmit data
			TXDATA {
				ec.Access : {0}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief Inter-integrated circuit
	I2C2 {
		ec.Peripheral : {0}
		ec.Size : {size : {0x400, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x40005800, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief Control register 1
		CR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Peripheral enable
			PE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TX Interrupt enable
			TXIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RX Interrupt enable
			RXIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Address match interrupt enable (slave\n              only)
			ADDRIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Not acknowledge received interrupt\n              enable
			NACKIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief STOP detection Interrupt\n              enable
			STOPIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transfer Complete interrupt\n              enable
			TCIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Error interrupts enable
			ERRIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Digital noise filter
			DNF {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Analog noise filter OFF
			ANFOFF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA transmission requests\n              enable
			TXDMAEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA reception requests\n              enable
			RXDMAEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Slave byte control
			SBC {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clock stretching disable
			NOSTRETCH {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Wakeup from STOP enable
			WUPEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief General call enable
			GCEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SMBus Host address enable
			SMBHEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SMBus Device Default address\n              enable
			SMBDEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SMBUS alert enable
			ALERTEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief PEC enable
			PECEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Control register 2
		CR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x4, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Packet error checking byte
			PECBYTE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Automatic end mode (master\n              mode)
			AUTOEND {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {25, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief NBYTES reload mode
			RELOAD {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Number of bytes
			NBYTES {
				ec.Access : {0}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief NACK generation (slave\n              mode)
			NACK {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Stop generation (master\n              mode)
			STOP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Start generation
			START {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief 10-bit address header only read\n              direction (master receiver mode)
			HEAD10R {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief 10-bit addressing mode (master\n              mode)
			ADD10 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transfer direction (master\n              mode)
			RD_WRN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Slave address bit (master\n              mode)
			SADD {
				ec.Access : {0}
				ec.Size : {size : {10, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Own address register 1
		OAR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x8, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Interface address
			OA1_0 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Interface address
			OA1_7_1 {
				ec.Access : {0}
				ec.Size : {size : {7, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Interface address
			OA1_8_9 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Own Address 1 10-bit mode
			OA1MODE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Own Address 1 enable
			OA1EN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Own address register 2
		OAR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xC, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Interface address
			OA2 {
				ec.Access : {0}
				ec.Size : {size : {7, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Own Address 2 masks
			OA2MSK {
				ec.Access : {0}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Own Address 2 enable
			OA2EN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Timing register
		TIMINGR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief SCL low period (master\n              mode)
			SCLL {
				ec.Access : {0}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SCL high period (master\n              mode)
			SCLH {
				ec.Access : {0}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Data hold time
			SDADEL {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Data setup time
			SCLDEL {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Timing prescaler
			PRESC {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Status register 1
		TIMEOUTR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x14, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Bus timeout A
			TIMEOUTA {
				ec.Access : {0}
				ec.Size : {size : {12, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Idle clock timeout\n              detection
			TIDLE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clock timeout enable
			TIMOUTEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Bus timeout B
			TIMEOUTB {
				ec.Access : {0}
				ec.Size : {size : {12, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Extended clock timeout\n              enable
			TEXTEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {31, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Interrupt and Status register
		ISR {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Address match code (Slave\n              mode)
			ADDCODE {
				ec.Access : {R}
				ec.Size : {size : {7, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transfer direction (Slave\n              mode)
			DIR {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Bus busy
			BUSY {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief SMBus alert
			ALERT {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Timeout or t_low detection\n              flag
			TIMEOUT {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief PEC Error in reception
			PECERR {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Overrun/Underrun (slave\n              mode)
			OVR {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Arbitration lost
			ARLO {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Bus error
			BERR {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transfer Complete Reload
			TCR {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transfer Complete (master\n              mode)
			TC {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Stop detection flag
			STOPF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Not acknowledge received\n              flag
			NACKF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Address matched (slave\n              mode)
			ADDR {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Receive data register not empty\n              (receivers)
			RXNE {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmit interrupt status\n              (transmitters)
			TXIS {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Transmit data register empty\n              (transmitters)
			TXE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Interrupt clear register
		ICR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x1C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Alert flag clear
			ALERTCF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Timeout detection flag\n              clear
			TIMOUTCF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief PEC Error flag clear
			PECCF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Overrun/Underrun flag\n              clear
			OVRCF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Arbitration lost flag\n              clear
			ARLOCF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Bus error flag clear
			BERRCF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Stop detection flag clear
			STOPCF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Not Acknowledge flag clear
			NACKCF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Address Matched flag clear
			ADDRCF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief PEC register
		PECR {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x20, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Packet error checking\n              register
			PEC {
				ec.Access : {0}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Receive data register
		RXDR {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x24, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief 8-bit receive data
			RXDATA {
				ec.Access : {0}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Transmit data register
		TXDR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x28, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief 8-bit transmit data
			TXDATA {
				ec.Access : {0}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief Real-time clock
	RTC {
		ec.Peripheral : {0}
		ec.Size : {size : {0x400, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x40002800, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief RTC time register 
		RTC_TR {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Second units in BCD format
			SU {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Second tens in BCD format
			ST {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Minute units in BCD format
			MNU {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Minute tens in BCD format
			MNT {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Hour units in BCD format
			HU {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Hour tens in BCD format
			HT {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief AM/PM notation
			PM {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RTC date register 
		RTC_DR {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x4, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Date units in BCD format
			DU {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Date tens in BCD format
			DT {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Month units in BCD format
			MU {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Month tens in BCD format
			MT {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Week day units\n...
			WDU {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Year units in BCD format
			YU {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Year tens in BCD format
			YT {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RTC sub second register 
		RTC_SSR {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x8, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Sub second value\nSS[15:0] is the value in the synchronous prescaler counter. The fraction of a second is given by the formula below:\nSecond fraction = (PREDIV_S - SS) / (PREDIV_S + 1)\nNote: SS can be larger than PREDIV_S only after a shift operation. In t
			SS {
				ec.Access : {R}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RTC initialization control and status register 
		RTC_ICSR {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xc, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Alarm A write flag\nThis bit is set by hardware when alarm A values can be changed, after the ALRAE bit has been set to 0 in RTC_CR.\nIt is cleared by hardware in initialization mode.
			ALRAWF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alarm B write flag\nThis bit is set by hardware when alarm B values can be changed, after the ALRBE bit has been set to 0 in RTC_CR.\nIt is cleared by hardware in initialization mode.
			ALRBWF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Wakeup timer write flag\nThis bit is set by hardware when WUT value can be changed, after the WUTE bit has been set to 0 in RTC_CR.\nIt is cleared by hardware in initialization mode.
			WUTWF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Shift operation pending\nThis flag is set by hardware as soon as a shift operation is initiated by a write to the RTC_SHIFTR register. It is cleared by hardware when the corresponding shift operation has been executed. Writing to the SHPF bit has no effect
			SHPF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Initialization status flag\nThis bit is set by hardware when the calendar year field is different from 0 (Backup domain reset state).
			INITS {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Registers synchronization flag\nThis bit is set by hardware each time the calendar registers are copied into the shadow registers (RTC_SSR, RTC_TR and RTC_DR). This bit is cleared by hardware in initialization mode, while a shift operation is pending (SHPF
			RSF {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Initialization flag\nWhen this bit is set to 1, the RTC is in initialization state, and the time, date and prescaler registers can be updated.
			INITF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Initialization mode
			INIT {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Recalibration pending Flag\nThe RECALPF status flag is automatically set to 1 when software writes to the RTC_CALR register, indicating that the RTC_CALR register is blocked. When the new calibration settings are taken into account, this bit returns to 0. 
			RECALPF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RTC prescaler register 
		RTC_PRER {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Synchronous prescaler factor\nThis is the synchronous division factor:\nck_spre frequency = ck_apre frequency/(PREDIV_S+1)
			PREDIV_S {
				ec.Access : {R|W}
				ec.Size : {size : {15, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Asynchronous prescaler factor\nThis is the asynchronous division factor:\nck_apre frequency = RTCCLK frequency/(PREDIV_A+1)
			PREDIV_A {
				ec.Access : {R|W}
				ec.Size : {size : {7, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RTC wakeup timer register 
		RTC_WUTR {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x14, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Wakeup auto-reload value bits\nWhen the wakeup timer is enabled (WUTE set to 1), the WUTF flag is set every (WUT[15:0]+1) ck_wut cycles. The ck_wut period is selected through WUCKSEL[2:0] bits of the RTC_CR register.\nWhen WUCKSEL[2] = 1, the wakeup timer b
			WUT {
				ec.Access : {R|W}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief control register
		RTC_CR {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief ck_wut wakeup clock selection\n10x: ck_spre (usually 1Hz) clock is selected\n11x: ck_spre (usually 1Hz) clock is selected and 216is added to the WUT counter value
			WUCKSEL {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Timestamp event active edge\nTSE must be reset when TSEDGE is changed to avoid unwanted TSF setting.
			TSEDGE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RTC_REFIN reference clock detection enable (50 or 60Hz)\nNote: PREDIV_S must be 0x00FF.
			REFCKON {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Bypass the shadow registers\nNote: If the frequency of the APB1 clock is less than seven times the frequency of RTCCLK, BYPSHAD must be set to 1.
			BYPSHAD {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Hour format
			FMT {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alarm A enable
			ALRAE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alarm B enable
			ALRBE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Wakeup timer enable\nNote: When the wakeup timer is disabled, wait for WUTWF=1 before enabling it again.
			WUTE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief timestamp enable
			TSE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alarm A interrupt enable
			ALRAIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alarm B interrupt enable
			ALRBIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Wakeup timer interrupt enable
			WUTIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Timestamp interrupt enable
			TSIE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Add 1 hour (summer time change)\nWhen this bit is set outside initialization mode, 1 hour is added to the calendar time. This bit is always read as 0.
			ADD1H {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Subtract 1 hour (winter time change)\nWhen this bit is set outside initialization mode, 1 hour is subtracted to the calendar time if the current hour is not 0. This bit is always read as 0.\nSetting this bit has no effect when current hour is 0.
			SUB1H {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Backup\nThis bit can be written by the user to memorize whether the daylight saving time change has been performed or not.
			BKP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Calibration output selection\nWhen COE = 1, this bit selects which signal is output on CALIB.\nThese frequencies are valid for RTCCLK at 32.768kHz and prescalers at their default values (PREDIV_A = 127 and PREDIV_S = 255). Refer to .
			COSEL {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {19, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output polarity\nThis bit is used to configure the polarity of TAMPALRM output.
			POL {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output selection\nThese bits are used to select the flag to be routed to TAMPALRM output.
			OSEL {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Calibration output enable\nThis bit enables the CALIB output
			COE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief timestamp on internal event enable
			ITSE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Activate timestamp on tamper detection event\nTAMPTS is valid even if TSE = 0 in the RTC_CR register. Timestamp flag is set after the tamper flags, therefore if TAMPTS and TSIE are set, it is recommended to disable the tamper interrupts in order to avoid s
			TAMPTS {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {25, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Tamper detection output enable on TAMPALRM
			TAMPOE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {26, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TAMPALRM pull-up enable
			TAMPALRM_PU {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {29, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TAMPALRM output type
			TAMPALRM_TYPE {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RTC_OUT2 output enable
			OUT2EN {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {31, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief write protection register
		RTC_WPR {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x24, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Write protection key\nThis byte is written by software.\nReading this byte always returns 0x00.\nRefer to  for a description of how to unlock RTC register write protection.
			KEY {
				ec.Access : {W}
				ec.Size : {size : {8, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RTC calibration register 
		RTC_CALR {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x28, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Calibration minus\nThe frequency of the calendar is reduced by masking CALM out of 220 RTCCLK pulses (32 seconds if the input frequency is 32768Hz). This decreases the frequency of the calendar with a resolution of 0.9537ppm.\nTo increase the frequency of t
			CALM {
				ec.Access : {R|W}
				ec.Size : {size : {9, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Use a 16-second calibration cycle period\nWhen CALW16 is set to 1, the 16-second calibration cycle period is selected. This bit must not be set to 1 if CALW8 = 1.\nNote: CALM[0] is stuck at 0 when CALW16 = 1. Refer to calibration.
			CALW16 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Use an 8-second calibration cycle period\nWhen CALW8 is set to 1, the 8-second calibration cycle period is selected.\nNote: CALM[1:0] are stuck at 00 when CALW8 = 1. Refer to digital calibration.
			CALW8 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Increase frequency of RTC by 488.5ppm\nThis feature is intended to be used in conjunction with CALM, which lowers the frequency of the calendar with a fine resolution. if the input frequency is 32768Hz, the number of RTCCLK pulses added during a 32-second 
			CALP {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RTC shift control register 
		RTC_SHIFTR {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x2c, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Subtract a fraction of a second\nThese bits are write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF = 1, in RTC_ICSR).\nThe value which is written to SUBFS is added to the synchronous prescal
			SUBFS {
				ec.Access : {W}
				ec.Size : {size : {15, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Add one second\nThis bit is write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF = 1, in RTC_ICSR).\nThis function is intended to be used with SUBFS (see description below) in order to effecti
			ADD1S {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {31, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RTC timestamp time register 
		RTC_TSTR {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x30, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Second units in BCD format.
			SU {
				ec.Access : {R}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Second tens in BCD format.
			ST {
				ec.Access : {R}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Minute units in BCD format.
			MNU {
				ec.Access : {R}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Minute tens in BCD format.
			MNT {
				ec.Access : {R}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Hour units in BCD format.
			HU {
				ec.Access : {R}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Hour tens in BCD format.
			HT {
				ec.Access : {R}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief AM/PM notation
			PM {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RTC timestamp date register 
		RTC_TSDR {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x34, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Date units in BCD format
			DU {
				ec.Access : {R}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Date tens in BCD format
			DT {
				ec.Access : {R}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Month units in BCD format
			MU {
				ec.Access : {R}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Month tens in BCD format
			MT {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Week day units
			WDU {
				ec.Access : {R}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RTC timestamp sub second register 
		RTC_TSSSR {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x38, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Sub second value\nSS[15:0] is the value of the synchronous prescaler counter when the timestamp event occurred.
			SS {
				ec.Access : {R}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RTC alarm A register 
		RTC_ALRMAR {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x40, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Second units in BCD format.
			SU {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Second tens in BCD format.
			ST {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alarm A seconds mask
			MSK1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Minute units in BCD format
			MNU {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Minute tens in BCD format
			MNT {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alarm A minutes mask
			MSK2 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Hour units in BCD format
			HU {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Hour tens in BCD format
			HT {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief AM/PM notation
			PM {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alarm A hours mask
			MSK3 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Date units or day in BCD format
			DU {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Date tens in BCD format
			DT {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Week day selection
			WDSEL {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alarm A date mask
			MSK4 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {31, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RTC alarm A sub second register 
		RTC_ALRMASSR {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x44, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Sub seconds value\nThis value is compared with the contents of the synchronous prescaler counter to determine if alarm A is to be activated. Only bits 0 up MASKSS-1 are compared.
			SS {
				ec.Access : {R|W}
				ec.Size : {size : {15, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Mask the most-significant bits starting at this bit\n2:\tSS[14:2] are don't care in alarm A comparison. Only SS[1:0] are compared.\n3:\tSS[14:3] are don't care in alarm A comparison. Only SS[2:0] are compared.\n...\n12:\tSS[14:12] are don't care in alarm A compa
			MASKSS {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RTC alarm B register 
		RTC_ALRMBR {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x48, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Second units in BCD format
			SU {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Second tens in BCD format
			ST {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alarm B seconds mask
			MSK1 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Minute units in BCD format
			MNU {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Minute tens in BCD format
			MNT {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alarm B minutes mask
			MSK2 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Hour units in BCD format
			HU {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Hour tens in BCD format
			HT {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief AM/PM notation
			PM {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {22, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alarm B hours mask
			MSK3 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {23, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Date units or day in BCD format
			DU {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Date tens in BCD format
			DT {
				ec.Access : {R|W}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {28, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Week day selection
			WDSEL {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {30, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alarm B date mask
			MSK4 {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {31, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RTC alarm B sub second register 
		RTC_ALRMBSSR {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x4c, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Sub seconds value\nThis value is compared with the contents of the synchronous prescaler counter to determine if alarm B is to be activated. Only bits 0 up to MASKSS-1 are compared.
			SS {
				ec.Access : {R|W}
				ec.Size : {size : {15, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Mask the most-significant bits starting at this bit\n...\nThe overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation.
			MASKSS {
				ec.Access : {R|W}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RTC status register 
		RTC_SR {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x50, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Alarm A flag\nThis flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the alarm A register (RTC_ALRMAR).
			ALRAF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alarm B flag\nThis flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the alarm B register (RTC_ALRMBR).
			ALRBF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Wakeup timer flag\nThis flag is set by hardware when the wakeup auto-reload counter reaches 0.\nThis flag must be cleared by software at least 1.5 RTCCLK periods before WUTF is set to 1 again.
			WUTF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Timestamp flag\nThis flag is set by hardware when a timestamp event occurs.\nIf ITSF flag is set, TSF must be cleared together with ITSF.
			TSF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Timestamp overflow flag\nThis flag is set by hardware when a timestamp event occurs while TSF is already set.\nIt is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a timestamp event 
			TSOVF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Internal timestamp flag\nThis flag is set by hardware when a timestamp on the internal event occurs.
			ITSF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RTC masked interrupt status register 
		RTC_MISR {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x54, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Alarm A masked flag\nThis flag is set by hardware when the alarm A interrupt occurs.
			ALRAMF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Alarm B masked flag\nThis flag is set by hardware when the alarm B interrupt occurs.
			ALRBMF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Wakeup timer masked flag\nThis flag is set by hardware when the wakeup timer interrupt occurs.\nThis flag must be cleared by software at least 1.5 RTCCLK periods before WUTF is set to 1 again.
			WUTMF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Timestamp masked flag\nThis flag is set by hardware when a timestamp interrupt occurs.\nIf ITSF flag is set, TSF must be cleared together with ITSF.
			TSMF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Timestamp overflow masked flag\nThis flag is set by hardware when a timestamp interrupt occurs while TSMF is already set.\nIt is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a time
			TSOVMF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Internal timestamp masked flag\nThis flag is set by hardware when a timestamp on the internal event occurs and timestampinterrupt is raised.
			ITSMF {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief RTC status clear register 
		RTC_SCR {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x5c, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Clear alarm A flag\nWriting 1 in this bit clears the ALRAF bit in the RTC_SR register.
			CALRAF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clear alarm B flag\nWriting 1 in this bit clears the ALRBF bit in the RTC_SR register.
			CALRBF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clear wakeup timer flag\nWriting 1 in this bit clears the WUTF bit in the RTC_SR register.
			CWUTF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clear timestamp flag\nWriting 1 in this bit clears the TSOVF bit in the RTC_SR register.\nIf ITSF flag is set, TSF must be cleared together with ITSF by setting CRSF and CITSF.
			CTSF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clear timestamp overflow flag\nWriting 1 in this bit clears the TSOVF bit in the RTC_SR register.\nIt is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a timestamp event occurs immed
			CTSOVF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clear internal timestamp flag\nWriting 1 in this bit clears the ITSF bit in the RTC_SR register.
			CITSF {
				ec.Access : {W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief General purpose timers
	TIM14 {
		ec.Peripheral : {0}
		ec.Size : {size : {0x400, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x40002000, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief control register 1
		CR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief UIF status bit remapping
			UIFREMAP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clock division
			CKD {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Auto-reload preload enable
			ARPE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief One-pulse mode
			OPM {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Update request source
			URS {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Update disable
			UDIS {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Counter enable
			CEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA/Interrupt enable register
		DIER {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xC, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare 1 interrupt\n              enable
			CC1IE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Update interrupt enable
			UIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief status register
		SR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare 1 overcapture\n              flag
			CC1OF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare 1 interrupt\n              flag
			CC1IF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Update interrupt flag
			UIF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief event generation register
		EGR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x14, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/compare 1\n              generation
			CC1G {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Update generation
			UG {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief capture/compare mode register 1 (output\n          mode)
		CCMR1_Output {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief CC1S
			CC1S {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief OC1FE
			OC1FE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief OC1PE
			OC1PE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief OC1M
			OC1M {
				ec.Access : {0}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief OC1CE
			OC1CE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Compare 1 mode - bit\n              3
			OC1M_3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief capture/compare mode register 1 (input\n          mode)
		CCMR1_Input {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Input capture 1 filter
			IC1F {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Input capture 1 prescaler
			ICPCS {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1\n              selection
			CC1S {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief capture/compare enable\n          register
		CCER {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x20, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare 1 output\n              Polarity
			CC1NP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 output\n              Polarity
			CC1P {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 output\n              enable
			CC1E {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief counter
		CNT {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x24, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief low counter value
			CNT {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief UIF Copy
			UIFCPY {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {31, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief prescaler
		PSC {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x28, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Prescaler value
			PSC {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief auto-reload register
		ARR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x2C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Low Auto-reload value
			ARR {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief capture/compare register 1
		CCR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x34, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Low Capture/Compare 1\n              value
			CCR1 {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM timer input selection\n          register
		TISEL {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x68, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief TI1[0] to TI1[15] input\n              selection
			TISEL {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief General-purpose-timers
	TIM2 {
		ec.Peripheral : {0}
		ec.Size : {size : {0x400, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x40000000, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief control register 1
		CR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief UIF status bit remapping
			UIFREMAP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clock division
			CKD {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Auto-reload preload enable
			ARPE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Center-aligned mode\n              selection
			CMS {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Direction
			DIR {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief One-pulse mode
			OPM {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Update request source
			URS {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Update disable
			UDIS {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Counter enable
			CEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief control register 2
		CR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x4, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief TI1 selection
			TI1S {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Master mode selection
			MMS {
				ec.Access : {0}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare DMA\n              selection
			CCDS {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief slave mode control register
		SMCR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x8, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Trigger selection
			TS_4_3 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Slave mode selection - bit\n              3
			SMS_3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief External trigger polarity
			ETP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief External clock enable
			ECE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief External trigger prescaler
			ETPS {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief External trigger filter
			ETF {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Master/Slave mode
			MSM {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Trigger selection
			TS {
				ec.Access : {0}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief OCREF clear selection
			OCCS {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Slave mode selection
			SMS {
				ec.Access : {0}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA/Interrupt enable register
		DIER {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xC, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Trigger DMA request enable
			TDE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 4 DMA request\n              enable
			CC4DE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 3 DMA request\n              enable
			CC3DE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 2 DMA request\n              enable
			CC2DE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 DMA request\n              enable
			CC1DE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Update DMA request enable
			UDE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Trigger interrupt enable
			TIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 4 interrupt\n              enable
			CC4IE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 3 interrupt\n              enable
			CC3IE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 2 interrupt\n              enable
			CC2IE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 interrupt\n              enable
			CC1IE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Update interrupt enable
			UIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief status register
		SR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare 4 overcapture\n              flag
			CC4OF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 3 overcapture\n              flag
			CC3OF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare 2 overcapture\n              flag
			CC2OF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 overcapture\n              flag
			CC1OF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Trigger interrupt flag
			TIF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 4 interrupt\n              flag
			CC4IF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 3 interrupt\n              flag
			CC3IF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 2 interrupt\n              flag
			CC2IF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare 1 interrupt\n              flag
			CC1IF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Update interrupt flag
			UIF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief event generation register
		EGR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x14, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Trigger generation
			TG {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare 4\n              generation
			CC4G {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare 3\n              generation
			CC3G {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare 2\n              generation
			CC2G {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare 1\n              generation
			CC1G {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Update generation
			UG {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief capture/compare mode register 1 (output\n          mode)
		CCMR1_Output {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Output Compare 2 mode - bit\n              3
			OC2M_3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Compare 1 mode - bit\n              3
			OC1M_3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 2 clear\n              enable
			OC2CE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 2 mode
			OC2M {
				ec.Access : {0}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 2 preload\n              enable
			OC2PE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 2 fast\n              enable
			OC2FE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 2\n              selection
			CC2S {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 1 clear\n              enable
			OC1CE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 1 mode
			OC1M {
				ec.Access : {0}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 1 preload\n              enable
			OC1PE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 1 fast\n              enable
			OC1FE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1\n              selection
			CC1S {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief capture/compare mode register 1 (input\n          mode)
		CCMR1_Input {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Input capture 2 filter
			IC2F {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Input capture 2 prescaler
			IC2PSC {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare 2\n              selection
			CC2S {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Input capture 1 filter
			IC1F {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Input capture 1 prescaler
			IC1PSC {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1\n              selection
			CC1S {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief capture/compare mode register 2 (output\n          mode)
		CCMR2_Output {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x1C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Output Compare 4 mode - bit\n              3
			OC4M_3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Compare 3 mode - bit\n              3
			OC3M_3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 4 clear\n              enable
			OC4CE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 4 mode
			OC4M {
				ec.Access : {0}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 4 preload\n              enable
			OC4PE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 4 fast\n              enable
			OC4FE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 4\n              selection
			CC4S {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 3 clear\n              enable
			OC3CE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 3 mode
			OC3M {
				ec.Access : {0}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 3 preload\n              enable
			OC3PE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 3 fast\n              enable
			OC3FE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 3\n              selection
			CC3S {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief capture/compare mode register 2 (input\n          mode)
		CCMR2_Input {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x1C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Input capture 4 filter
			IC4F {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Input capture 4 prescaler
			IC4PSC {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 4\n              selection
			CC4S {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Input capture 3 filter
			IC3F {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Input capture 3 prescaler
			IC3PSC {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 3\n              selection
			CC3S {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief capture/compare enable\n          register
		CCER {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x20, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare 4 output\n              Polarity
			CC4NP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 3 output\n              Polarity
			CC4P {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 4 output\n              enable
			CC4E {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 3 output\n              Polarity
			CC3NP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 3 output\n              Polarity
			CC3P {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 3 output\n              enable
			CC3E {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 2 output\n              Polarity
			CC2NP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 2 output\n              Polarity
			CC2P {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 2 output\n              enable
			CC2E {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 output\n              Polarity
			CC1NP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 output\n              Polarity
			CC1P {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 output\n              enable
			CC1E {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief counter
		CNT {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x24, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief High counter value (TIM2\n              only)
			CNT_H {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Low counter value
			CNT_L {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief prescaler
		PSC {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x28, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Prescaler value
			PSC {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief auto-reload register
		ARR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x2C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief High Auto-reload value (TIM2\n              only)
			ARR_H {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Low Auto-reload value
			ARR_L {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief capture/compare register 1
		CCR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x34, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief High Capture/Compare 1 value (TIM2\n              only)
			CCR1_H {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Low Capture/Compare 1\n              value
			CCR1_L {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief capture/compare register 2
		CCR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x38, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief High Capture/Compare 2 value (TIM2\n              only)
			CCR2_H {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Low Capture/Compare 2\n              value
			CCR2_L {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief capture/compare register 3
		CCR3 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x3C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief High Capture/Compare value (TIM2\n              only)
			CCR3_H {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Low Capture/Compare value
			CCR3_L {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief capture/compare register 4
		CCR4 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x40, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief High Capture/Compare value (TIM2\n              only)
			CCR4_H {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Low Capture/Compare value
			CCR4_L {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA control register
		DCR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x48, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief DMA burst length
			DBL {
				ec.Access : {0}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA base address
			DBA {
				ec.Access : {0}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA address for full transfer
		DMAR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x4C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief DMA register for burst\n              accesses
			DMAB {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM option register
		OR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x50, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief IOCREF_CLR
			IOCREF_CLR {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM alternate function option register\n          1
		AF1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x60, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief External trigger source\n              selection
			ETRSEL {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM alternate function option register\n          1
		TISEL {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x68, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief TI1SEL
			TI1SEL {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TI2SEL
			TI2SEL {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief General-purpose-timers
	TIM3 {
		ec.Peripheral : {0}
		ec.Size : {size : {0x400, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x40000400, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief control register 1
		CR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief UIF status bit remapping
			UIFREMAP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Clock division
			CKD {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Auto-reload preload enable
			ARPE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Center-aligned mode\n              selection
			CMS {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Direction
			DIR {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief One-pulse mode
			OPM {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Update request source
			URS {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Update disable
			UDIS {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Counter enable
			CEN {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief control register 2
		CR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x4, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief TI1 selection
			TI1S {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Master mode selection
			MMS {
				ec.Access : {0}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare DMA\n              selection
			CCDS {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief slave mode control register
		SMCR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x8, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Trigger selection
			TS_4_3 {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {20, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Slave mode selection - bit\n              3
			SMS_3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief External trigger polarity
			ETP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief External clock enable
			ECE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief External trigger prescaler
			ETPS {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief External trigger filter
			ETF {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Master/Slave mode
			MSM {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Trigger selection
			TS {
				ec.Access : {0}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief OCREF clear selection
			OCCS {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Slave mode selection
			SMS {
				ec.Access : {0}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA/Interrupt enable register
		DIER {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xC, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Trigger DMA request enable
			TDE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 4 DMA request\n              enable
			CC4DE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 3 DMA request\n              enable
			CC3DE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 2 DMA request\n              enable
			CC2DE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 DMA request\n              enable
			CC1DE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Update DMA request enable
			UDE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Trigger interrupt enable
			TIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 4 interrupt\n              enable
			CC4IE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 3 interrupt\n              enable
			CC3IE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 2 interrupt\n              enable
			CC2IE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 interrupt\n              enable
			CC1IE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Update interrupt enable
			UIE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief status register
		SR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x10, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare 4 overcapture\n              flag
			CC4OF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 3 overcapture\n              flag
			CC3OF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare 2 overcapture\n              flag
			CC2OF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 overcapture\n              flag
			CC1OF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Trigger interrupt flag
			TIF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 4 interrupt\n              flag
			CC4IF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 3 interrupt\n              flag
			CC3IF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 2 interrupt\n              flag
			CC2IF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare 1 interrupt\n              flag
			CC1IF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Update interrupt flag
			UIF {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief event generation register
		EGR {
			ec.Access : {W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x14, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Trigger generation
			TG {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {6, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare 4\n              generation
			CC4G {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare 3\n              generation
			CC3G {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare 2\n              generation
			CC2G {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare 1\n              generation
			CC1G {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Update generation
			UG {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief capture/compare mode register 1 (output\n          mode)
		CCMR1_Output {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Output Compare 2 mode - bit\n              3
			OC2M_3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Compare 1 mode - bit\n              3
			OC1M_3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 2 clear\n              enable
			OC2CE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 2 mode
			OC2M {
				ec.Access : {0}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 2 preload\n              enable
			OC2PE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 2 fast\n              enable
			OC2FE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 2\n              selection
			CC2S {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 1 clear\n              enable
			OC1CE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 1 mode
			OC1M {
				ec.Access : {0}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 1 preload\n              enable
			OC1PE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 1 fast\n              enable
			OC1FE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1\n              selection
			CC1S {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief capture/compare mode register 1 (input\n          mode)
		CCMR1_Input {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x18, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Input capture 2 filter
			IC2F {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Input capture 2 prescaler
			IC2PSC {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/compare 2\n              selection
			CC2S {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Input capture 1 filter
			IC1F {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Input capture 1 prescaler
			IC1PSC {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1\n              selection
			CC1S {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief capture/compare mode register 2 (output\n          mode)
		CCMR2_Output {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x1C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Output Compare 4 mode - bit\n              3
			OC4M_3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {24, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output Compare 3 mode - bit\n              3
			OC3M_3 {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 4 clear\n              enable
			OC4CE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 4 mode
			OC4M {
				ec.Access : {0}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 4 preload\n              enable
			OC4PE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 4 fast\n              enable
			OC4FE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 4\n              selection
			CC4S {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 3 clear\n              enable
			OC3CE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 3 mode
			OC3M {
				ec.Access : {0}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 3 preload\n              enable
			OC3PE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Output compare 3 fast\n              enable
			OC3FE {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 3\n              selection
			CC3S {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief capture/compare mode register 2 (input\n          mode)
		CCMR2_Input {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x1C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Input capture 4 filter
			IC4F {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Input capture 4 prescaler
			IC4PSC {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 4\n              selection
			CC4S {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Input capture 3 filter
			IC3F {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Input capture 3 prescaler
			IC3PSC {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 3\n              selection
			CC3S {
				ec.Access : {0}
				ec.Size : {size : {2, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief capture/compare enable\n          register
		CCER {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x20, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Capture/Compare 4 output\n              Polarity
			CC4NP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 3 output\n              Polarity
			CC4P {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {13, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 4 output\n              enable
			CC4E {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 3 output\n              Polarity
			CC3NP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 3 output\n              Polarity
			CC3P {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {9, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 3 output\n              enable
			CC3E {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 2 output\n              Polarity
			CC2NP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {7, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 2 output\n              Polarity
			CC2P {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {5, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 2 output\n              enable
			CC2E {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 output\n              Polarity
			CC1NP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 output\n              Polarity
			CC1P {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Capture/Compare 1 output\n              enable
			CC1E {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief counter
		CNT {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x24, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief High counter value (TIM2\n              only)
			CNT_H {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Low counter value
			CNT_L {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief prescaler
		PSC {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x28, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Prescaler value
			PSC {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief auto-reload register
		ARR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x2C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief High Auto-reload value (TIM2\n              only)
			ARR_H {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Low Auto-reload value
			ARR_L {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief capture/compare register 1
		CCR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x34, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief High Capture/Compare 1 value (TIM2\n              only)
			CCR1_H {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Low Capture/Compare 1\n              value
			CCR1_L {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief capture/compare register 2
		CCR2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x38, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief High Capture/Compare 2 value (TIM2\n              only)
			CCR2_H {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Low Capture/Compare 2\n              value
			CCR2_L {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief capture/compare register 3
		CCR3 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x3C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief High Capture/Compare value (TIM2\n              only)
			CCR3_H {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Low Capture/Compare value
			CCR3_L {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief capture/compare register 4
		CCR4 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x40, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief High Capture/Compare value (TIM2\n              only)
			CCR4_H {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Low Capture/Compare value
			CCR4_L {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA control register
		DCR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x48, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief DMA burst length
			DBL {
				ec.Access : {0}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DMA base address
			DBA {
				ec.Access : {0}
				ec.Size : {size : {5, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief DMA address for full transfer
		DMAR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x4C, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief DMA register for burst\n              accesses
			DMAB {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM option register
		OR1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x50, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief IOCREF_CLR
			IOCREF_CLR {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM alternate function option register\n          1
		AF1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x60, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief External trigger source\n              selection
			ETRSEL {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {14, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief TIM alternate function option register\n          1
		TISEL {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x68, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief TI1SEL
			TI1SEL {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TI2SEL
			TI2SEL {
				ec.Access : {0}
				ec.Size : {size : {4, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {8, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief System configuration controller
	VREFBUF {
		ec.Peripheral : {0}
		ec.Size : {size : {0x50, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x40010030, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief VREFBUF control and status\n          register
		CSR {
			ec.Access : {0}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Voltage reference buffer mode enable\n              This bit is used to enable the voltage reference\n              buffer mode.
			ENVR {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief High impedance mode This bit controls\n              the analog switch to connect or not the VREF+ pin.\n              Refer to Table196: VREF buffer modes for the mode\n              descriptions depending on ENVR bit\n              configuration.
			HIZ {
				ec.Access : {R|W}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Voltage reference buffer\n              ready
			VRR {
				ec.Access : {R}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {3, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Voltage reference scale These bits\n              select the value generated by the voltage reference\n              buffer. Other: Reserved
			VRS {
				ec.Access : {R|W}
				ec.Size : {size : {3, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {4, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief VREFBUF calibration control\n          register
		CCR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x4, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Trimming code These bits are\n              automatically initialized after reset with the\n              trimming value stored in the Flash memory during the\n              production test. Writing into these bits allows to\n              tune the internal r
			TRIM {
				ec.Access : {0}
				ec.Size : {size : {6, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
		}
	}
	@color #9b2316
	@brief MCU debug component
	DBG {
		ec.Peripheral : {0}
		ec.Size : {size : {0x400, unit:flecs.units.Data.Bytes}}
		ec.Offset : {offset : {0x40015800, unit:flecs.units.Data.Bytes}}
		@color #2b6316
		@brief DBGMCU_IDCODE
		IDCODE {
			ec.Access : {R}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x0, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Device identifier
			DEV_ID {
				ec.Access : {0}
				ec.Size : {size : {12, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Revision identifie
			REV_ID {
				ec.Access : {0}
				ec.Size : {size : {16, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {16, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Debug MCU configuration\n          register
		CR {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x4, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief Debug Stop mode
			DBG_STOP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Debug Standby mode
			DBG_STANDBY {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {2, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Debug MCU APB1 freeze\n          register1
		APB_FZ1 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0x8, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief TIM2 counter stopped when core is\n              halted
			DBG_TIM2_STOP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {0, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief TIM3 counter stopped when core is\n              halted
			DBG_TIM3_STOP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {1, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief RTC counter stopped when core is\n              halted
			DBG_RTC_STOP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {10, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Window watchdog counter stopped when\n              core is halted
			DBG_WWDG_STOP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief Independent watchdog counter stopped\n              when core is halted
			DBG_IWDG_STOP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {12, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief I2C1 SMBUS timeout counter stopped when\n              core is halted
			DBG_I2C1_STOP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {21, unit:flecs.units.Data.Bits}}
			}
		}
		@color #2b6316
		@brief Debug MCU APB1 freeze register\n          2
		APB_FZ2 {
			ec.Access : {R|W}
			ec.Size : {size : {0x20, unit:flecs.units.Data.Bits}}
			ec.Offset : {offset : {0xC, unit:flecs.units.Data.Bytes}}
			@color #6b93d6
			@brief TIM1 counter stopped when core is\n              halted
			DBG_TIM1_STOP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {11, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DBG_TIM14_STOP
			DBG_TIM14_STOP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {15, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DBG_TIM16_STOP
			DBG_TIM16_STOP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {17, unit:flecs.units.Data.Bits}}
			}
			@color #6b93d6
			@brief DBG_TIM17_STOP
			DBG_TIM17_STOP {
				ec.Access : {0}
				ec.Size : {size : {1, unit:flecs.units.Data.Bits}}
				ec.Offset : {offset : {18, unit:flecs.units.Data.Bits}}
			}
		}
	}
}
signals {
	LPTIM1_OUT {
		ec.Signal : {0}
	}
	SPI2_SCK {
		ec.Signal : {0}
	}
	TIM2_CH1 {
		ec.Signal : {0}
	}
	TIM2_ETR {
		ec.Signal : {0}
	}
	USART2_CTS {
		ec.Signal : {0}
	}
	USART2_NSS {
		ec.Signal : {0}
	}
	EVENTOUT {
		ec.Signal : {0}
	}
	I2C1_SMBA {
		ec.Signal : {0}
	}
	I2S1_CK {
		ec.Signal : {0}
	}
	SPI1_SCK {
		ec.Signal : {0}
	}
	TIM2_CH2 {
		ec.Signal : {0}
	}
	USART2_CK {
		ec.Signal : {0}
	}
	USART2_DE {
		ec.Signal : {0}
	}
	USART2_RTS {
		ec.Signal : {0}
	}
	I2C1_SDA {
		ec.Signal : {0}
	}
	SPI2_MOSI {
		ec.Signal : {0}
	}
	TIM17_BK {
		ec.Signal : {0}
	}
	TIM1_CH3 {
		ec.Signal : {0}
	}
	USART1_RX {
		ec.Signal : {0}
	}
	I2C2_SCL {
		ec.Signal : {0}
	}
	I2S1_MCK {
		ec.Signal : {0}
	}
	SPI1_MISO {
		ec.Signal : {0}
	}
	TIM1_BK2 {
		ec.Signal : {0}
	}
	TIM1_CH4 {
		ec.Signal : {0}
	}
	USART1_CTS {
		ec.Signal : {0}
	}
	USART1_NSS {
		ec.Signal : {0}
	}
	I2C2_SDA {
		ec.Signal : {0}
	}
	I2S1_SD {
		ec.Signal : {0}
	}
	I2S_CKIN {
		ec.Signal : {0}
	}
	SPI1_MOSI {
		ec.Signal : {0}
	}
	TIM1_ETR {
		ec.Signal : {0}
	}
	USART1_CK {
		ec.Signal : {0}
	}
	USART1_DE {
		ec.Signal : {0}
	}
	USART1_RTS {
		ec.Signal : {0}
	}
	IR_OUT {
		ec.Signal : {0}
	}
	SYS_SWDIO {
		ec.Signal : {0}
	}
	SYS_SWCLK {
		ec.Signal : {0}
	}
	USART2_TX {
		ec.Signal : {0}
	}
	I2S1_WS {
		ec.Signal : {0}
	}
	SPI1_NSS {
		ec.Signal : {0}
	}
	USART2_RX {
		ec.Signal : {0}
	}
	LPUART1_TX {
		ec.Signal : {0}
	}
	TIM2_CH3 {
		ec.Signal : {0}
	}
	LPUART1_RX {
		ec.Signal : {0}
	}
	SPI2_MISO {
		ec.Signal : {0}
	}
	TIM2_CH4 {
		ec.Signal : {0}
	}
	LPTIM2_OUT {
		ec.Signal : {0}
	}
	TIM14_CH1 {
		ec.Signal : {0}
	}
	LPTIM2_ETR {
		ec.Signal : {0}
	}
	LPUART1_CTS {
		ec.Signal : {0}
	}
	TIM16_CH1 {
		ec.Signal : {0}
	}
	TIM1_BK {
		ec.Signal : {0}
	}
	TIM3_CH1 {
		ec.Signal : {0}
	}
	TIM17_CH1 {
		ec.Signal : {0}
	}
	TIM1_CH1N {
		ec.Signal : {0}
	}
	TIM3_CH2 {
		ec.Signal : {0}
	}
	RCC_MCO {
		ec.Signal : {0}
	}
	SPI2_NSS {
		ec.Signal : {0}
	}
	TIM1_CH1 {
		ec.Signal : {0}
	}
	I2C1_SCL {
		ec.Signal : {0}
	}
	TIM15_BK {
		ec.Signal : {0}
	}
	TIM1_CH2 {
		ec.Signal : {0}
	}
	USART1_TX {
		ec.Signal : {0}
	}
	TIM1_CH2N {
		ec.Signal : {0}
	}
	TIM3_CH3 {
		ec.Signal : {0}
	}
	LPTIM2_IN1 {
		ec.Signal : {0}
	}
	LPUART1_DE {
		ec.Signal : {0}
	}
	LPUART1_RTS {
		ec.Signal : {0}
	}
	TIM1_CH3N {
		ec.Signal : {0}
	}
	TIM3_CH4 {
		ec.Signal : {0}
	}
	LPTIM1_IN1 {
		ec.Signal : {0}
	}
	TIM16_BK {
		ec.Signal : {0}
	}
	LPTIM1_ETR {
		ec.Signal : {0}
	}
	TIM16_CH1N {
		ec.Signal : {0}
	}
	LPTIM1_IN2 {
		ec.Signal : {0}
	}
	TIM17_CH1N {
		ec.Signal : {0}
	}
	RCC_OSC32_EN {
		ec.Signal : {0}
	}
	RCC_OSC_EN {
		ec.Signal : {0}
	}
	TIM3_ETR {
		ec.Signal : {0}
	}
}
pins {
	PA0 {
		ec.Pin : {}
		AF5_LPTIM1_OUT : signals.LPTIM1_OUT {
		}
		AF0_SPI2_SCK : signals.SPI2_SCK {
		}
		AF2_TIM2_CH1 : signals.TIM2_CH1 {
		}
		AF2_TIM2_ETR : signals.TIM2_ETR {
		}
		AF1_USART2_CTS : signals.USART2_CTS {
		}
		AF1_USART2_NSS : signals.USART2_NSS {
		}
	}
	PA1 {
		ec.Pin : {}
		AF7_EVENTOUT : signals.EVENTOUT {
		}
		AF6_I2C1_SMBA : signals.I2C1_SMBA {
		}
		AF0_I2S1_CK : signals.I2S1_CK {
		}
		AF0_SPI1_SCK : signals.SPI1_SCK {
		}
		AF2_TIM2_CH2 : signals.TIM2_CH2 {
		}
		AF1_USART2_CK : signals.USART2_CK {
		}
		AF1_USART2_DE : signals.USART2_DE {
		}
		AF1_USART2_RTS : signals.USART2_RTS {
		}
	}
	PA10 {
		ec.Pin : {}
		AF7_EVENTOUT : signals.EVENTOUT {
		}
		AF6_I2C1_SDA : signals.I2C1_SDA {
		}
		AF0_SPI2_MOSI : signals.SPI2_MOSI {
		}
		AF5_TIM17_BK : signals.TIM17_BK {
		}
		AF2_TIM1_CH3 : signals.TIM1_CH3 {
		}
		AF1_USART1_RX : signals.USART1_RX {
		}
	}
	PA10__PA12_ {
		ec.Pin : {}
		AF7_EVENTOUT : signals.EVENTOUT {
		}
		AF6_I2C1_SDA : signals.I2C1_SDA {
		}
		AF0_SPI2_MOSI : signals.SPI2_MOSI {
		}
		AF5_TIM17_BK : signals.TIM17_BK {
		}
		AF2_TIM1_CH3 : signals.TIM1_CH3 {
		}
		AF1_USART1_RX : signals.USART1_RX {
		}
	}
	PA11__PA9_ {
		ec.Pin : {}
		AF6_I2C2_SCL : signals.I2C2_SCL {
		}
		AF0_I2S1_MCK : signals.I2S1_MCK {
		}
		AF0_SPI1_MISO : signals.SPI1_MISO {
		}
		AF5_TIM1_BK2 : signals.TIM1_BK2 {
		}
		AF2_TIM1_CH4 : signals.TIM1_CH4 {
		}
		AF1_USART1_CTS : signals.USART1_CTS {
		}
		AF1_USART1_NSS : signals.USART1_NSS {
		}
	}
	PA12__PA10_ {
		ec.Pin : {}
		AF6_I2C2_SDA : signals.I2C2_SDA {
		}
		AF0_I2S1_SD : signals.I2S1_SD {
		}
		AF5_I2S_CKIN : signals.I2S_CKIN {
		}
		AF0_SPI1_MOSI : signals.SPI1_MOSI {
		}
		AF2_TIM1_ETR : signals.TIM1_ETR {
		}
		AF1_USART1_CK : signals.USART1_CK {
		}
		AF1_USART1_DE : signals.USART1_DE {
		}
		AF1_USART1_RTS : signals.USART1_RTS {
		}
	}
	PA13 {
		ec.Pin : {}
		AF7_EVENTOUT : signals.EVENTOUT {
		}
		AF1_IR_OUT : signals.IR_OUT {
		}
		AF0_SYS_SWDIO : signals.SYS_SWDIO {
		}
	}
	PA14_BOOT0 {
		ec.Pin : {}
		AF7_EVENTOUT : signals.EVENTOUT {
		}
		AF0_SYS_SWCLK : signals.SYS_SWCLK {
		}
		AF1_USART2_TX : signals.USART2_TX {
		}
	}
	PA15 {
		ec.Pin : {}
		AF7_EVENTOUT : signals.EVENTOUT {
		}
		AF0_I2S1_WS : signals.I2S1_WS {
		}
		AF0_SPI1_NSS : signals.SPI1_NSS {
		}
		AF2_TIM2_CH1 : signals.TIM2_CH1 {
		}
		AF2_TIM2_ETR : signals.TIM2_ETR {
		}
		AF1_USART2_RX : signals.USART2_RX {
		}
	}
	PA2 {
		ec.Pin : {}
		AF0_I2S1_SD : signals.I2S1_SD {
		}
		AF6_LPUART1_TX : signals.LPUART1_TX {
		}
		AF0_SPI1_MOSI : signals.SPI1_MOSI {
		}
		AF2_TIM2_CH3 : signals.TIM2_CH3 {
		}
		AF1_USART2_TX : signals.USART2_TX {
		}
	}
	PA3 {
		ec.Pin : {}
		AF7_EVENTOUT : signals.EVENTOUT {
		}
		AF6_LPUART1_RX : signals.LPUART1_RX {
		}
		AF0_SPI2_MISO : signals.SPI2_MISO {
		}
		AF2_TIM2_CH4 : signals.TIM2_CH4 {
		}
		AF1_USART2_RX : signals.USART2_RX {
		}
	}
	PA4 {
		ec.Pin : {}
		AF7_EVENTOUT : signals.EVENTOUT {
		}
		AF0_I2S1_WS : signals.I2S1_WS {
		}
		AF5_LPTIM2_OUT : signals.LPTIM2_OUT {
		}
		AF0_SPI1_NSS : signals.SPI1_NSS {
		}
		AF1_SPI2_MOSI : signals.SPI2_MOSI {
		}
		AF4_TIM14_CH1 : signals.TIM14_CH1 {
		}
	}
	PA5 {
		ec.Pin : {}
		AF7_EVENTOUT : signals.EVENTOUT {
		}
		AF0_I2S1_CK : signals.I2S1_CK {
		}
		AF5_LPTIM2_ETR : signals.LPTIM2_ETR {
		}
		AF0_SPI1_SCK : signals.SPI1_SCK {
		}
		AF2_TIM2_CH1 : signals.TIM2_CH1 {
		}
		AF2_TIM2_ETR : signals.TIM2_ETR {
		}
	}
	PA6 {
		ec.Pin : {}
		AF0_I2S1_MCK : signals.I2S1_MCK {
		}
		AF6_LPUART1_CTS : signals.LPUART1_CTS {
		}
		AF0_SPI1_MISO : signals.SPI1_MISO {
		}
		AF5_TIM16_CH1 : signals.TIM16_CH1 {
		}
		AF2_TIM1_BK : signals.TIM1_BK {
		}
		AF1_TIM3_CH1 : signals.TIM3_CH1 {
		}
	}
	PA7 {
		ec.Pin : {}
		AF0_I2S1_SD : signals.I2S1_SD {
		}
		AF0_SPI1_MOSI : signals.SPI1_MOSI {
		}
		AF4_TIM14_CH1 : signals.TIM14_CH1 {
		}
		AF5_TIM17_CH1 : signals.TIM17_CH1 {
		}
		AF2_TIM1_CH1N : signals.TIM1_CH1N {
		}
		AF1_TIM3_CH2 : signals.TIM3_CH2 {
		}
	}
	PA8 {
		ec.Pin : {}
		AF7_EVENTOUT : signals.EVENTOUT {
		}
		AF5_LPTIM2_OUT : signals.LPTIM2_OUT {
		}
		AF0_RCC_MCO : signals.RCC_MCO {
		}
		AF1_SPI2_NSS : signals.SPI2_NSS {
		}
		AF2_TIM1_CH1 : signals.TIM1_CH1 {
		}
	}
	PA9 {
		ec.Pin : {}
		AF7_EVENTOUT : signals.EVENTOUT {
		}
		AF6_I2C1_SCL : signals.I2C1_SCL {
		}
		AF0_RCC_MCO : signals.RCC_MCO {
		}
		AF4_SPI2_MISO : signals.SPI2_MISO {
		}
		AF5_TIM15_BK : signals.TIM15_BK {
		}
		AF2_TIM1_CH2 : signals.TIM1_CH2 {
		}
		AF1_USART1_TX : signals.USART1_TX {
		}
	}
	PA9__PA11_ {
		ec.Pin : {}
		AF7_EVENTOUT : signals.EVENTOUT {
		}
		AF6_I2C1_SCL : signals.I2C1_SCL {
		}
		AF0_RCC_MCO : signals.RCC_MCO {
		}
		AF4_SPI2_MISO : signals.SPI2_MISO {
		}
		AF2_TIM1_CH2 : signals.TIM1_CH2 {
		}
		AF1_USART1_TX : signals.USART1_TX {
		}
	}
	PB0 {
		ec.Pin : {}
		AF0_I2S1_WS : signals.I2S1_WS {
		}
		AF5_LPTIM1_OUT : signals.LPTIM1_OUT {
		}
		AF0_SPI1_NSS : signals.SPI1_NSS {
		}
		AF2_TIM1_CH2N : signals.TIM1_CH2N {
		}
		AF1_TIM3_CH3 : signals.TIM3_CH3 {
		}
	}
	PB1 {
		ec.Pin : {}
		AF7_EVENTOUT : signals.EVENTOUT {
		}
		AF5_LPTIM2_IN1 : signals.LPTIM2_IN1 {
		}
		AF6_LPUART1_DE : signals.LPUART1_DE {
		}
		AF6_LPUART1_RTS : signals.LPUART1_RTS {
		}
		AF0_TIM14_CH1 : signals.TIM14_CH1 {
		}
		AF2_TIM1_CH3N : signals.TIM1_CH3N {
		}
		AF1_TIM3_CH4 : signals.TIM3_CH4 {
		}
	}
	PB10 {
		ec.Pin : {}
		AF6_I2C2_SCL : signals.I2C2_SCL {
		}
		AF1_LPUART1_RX : signals.LPUART1_RX {
		}
		AF5_SPI2_SCK : signals.SPI2_SCK {
		}
		AF2_TIM2_CH3 : signals.TIM2_CH3 {
		}
	}
	PB11 {
		ec.Pin : {}
		AF6_I2C2_SDA : signals.I2C2_SDA {
		}
		AF1_LPUART1_TX : signals.LPUART1_TX {
		}
		AF0_SPI2_MOSI : signals.SPI2_MOSI {
		}
		AF2_TIM2_CH4 : signals.TIM2_CH4 {
		}
	}
	PB12 {
		ec.Pin : {}
		AF7_EVENTOUT : signals.EVENTOUT {
		}
		AF1_LPUART1_DE : signals.LPUART1_DE {
		}
		AF1_LPUART1_RTS : signals.LPUART1_RTS {
		}
		AF0_SPI2_NSS : signals.SPI2_NSS {
		}
		AF2_TIM1_BK : signals.TIM1_BK {
		}
	}
	PB13 {
		ec.Pin : {}
		AF7_EVENTOUT : signals.EVENTOUT {
		}
		AF6_I2C2_SCL : signals.I2C2_SCL {
		}
		AF1_LPUART1_CTS : signals.LPUART1_CTS {
		}
		AF0_SPI2_SCK : signals.SPI2_SCK {
		}
		AF2_TIM1_CH1N : signals.TIM1_CH1N {
		}
	}
	PB14 {
		ec.Pin : {}
		AF7_EVENTOUT : signals.EVENTOUT {
		}
		AF6_I2C2_SDA : signals.I2C2_SDA {
		}
		AF0_SPI2_MISO : signals.SPI2_MISO {
		}
		AF2_TIM1_CH2N : signals.TIM1_CH2N {
		}
	}
	PB15 {
		ec.Pin : {}
		AF7_EVENTOUT : signals.EVENTOUT {
		}
		AF0_SPI2_MOSI : signals.SPI2_MOSI {
		}
		AF2_TIM1_CH3N : signals.TIM1_CH3N {
		}
	}
	PB2 {
		ec.Pin : {}
		AF7_EVENTOUT : signals.EVENTOUT {
		}
		AF5_LPTIM1_OUT : signals.LPTIM1_OUT {
		}
		AF1_SPI2_MISO : signals.SPI2_MISO {
		}
	}
	PB3 {
		ec.Pin : {}
		AF7_EVENTOUT : signals.EVENTOUT {
		}
		AF0_I2S1_CK : signals.I2S1_CK {
		}
		AF0_SPI1_SCK : signals.SPI1_SCK {
		}
		AF1_TIM1_CH2 : signals.TIM1_CH2 {
		}
		AF2_TIM2_CH2 : signals.TIM2_CH2 {
		}
		AF4_USART1_CK : signals.USART1_CK {
		}
		AF4_USART1_DE : signals.USART1_DE {
		}
		AF4_USART1_RTS : signals.USART1_RTS {
		}
	}
	PB4 {
		ec.Pin : {}
		AF7_EVENTOUT : signals.EVENTOUT {
		}
		AF0_I2S1_MCK : signals.I2S1_MCK {
		}
		AF0_SPI1_MISO : signals.SPI1_MISO {
		}
		AF5_TIM17_BK : signals.TIM17_BK {
		}
		AF1_TIM3_CH1 : signals.TIM3_CH1 {
		}
		AF4_USART1_CTS : signals.USART1_CTS {
		}
		AF4_USART1_NSS : signals.USART1_NSS {
		}
	}
	PB5 {
		ec.Pin : {}
		AF6_I2C1_SMBA : signals.I2C1_SMBA {
		}
		AF0_I2S1_SD : signals.I2S1_SD {
		}
		AF5_LPTIM1_IN1 : signals.LPTIM1_IN1 {
		}
		AF0_SPI1_MOSI : signals.SPI1_MOSI {
		}
		AF2_TIM16_BK : signals.TIM16_BK {
		}
		AF1_TIM3_CH2 : signals.TIM3_CH2 {
		}
	}
	PB6 {
		ec.Pin : {}
		AF7_EVENTOUT : signals.EVENTOUT {
		}
		AF6_I2C1_SCL : signals.I2C1_SCL {
		}
		AF5_LPTIM1_ETR : signals.LPTIM1_ETR {
		}
		AF4_SPI2_MISO : signals.SPI2_MISO {
		}
		AF2_TIM16_CH1N : signals.TIM16_CH1N {
		}
		AF1_TIM1_CH3 : signals.TIM1_CH3 {
		}
		AF0_USART1_TX : signals.USART1_TX {
		}
	}
	PB7 {
		ec.Pin : {}
		AF7_EVENTOUT : signals.EVENTOUT {
		}
		AF6_I2C1_SDA : signals.I2C1_SDA {
		}
		AF5_LPTIM1_IN2 : signals.LPTIM1_IN2 {
		}
		AF1_SPI2_MOSI : signals.SPI2_MOSI {
		}
		AF2_TIM17_CH1N : signals.TIM17_CH1N {
		}
		AF0_USART1_RX : signals.USART1_RX {
		}
	}
	PB8 {
		ec.Pin : {}
		AF7_EVENTOUT : signals.EVENTOUT {
		}
		AF6_I2C1_SCL : signals.I2C1_SCL {
		}
		AF1_SPI2_SCK : signals.SPI2_SCK {
		}
		AF2_TIM16_CH1 : signals.TIM16_CH1 {
		}
	}
	PB9 {
		ec.Pin : {}
		AF7_EVENTOUT : signals.EVENTOUT {
		}
		AF6_I2C1_SDA : signals.I2C1_SDA {
		}
		AF0_IR_OUT : signals.IR_OUT {
		}
		AF5_SPI2_NSS : signals.SPI2_NSS {
		}
		AF2_TIM17_CH1 : signals.TIM17_CH1 {
		}
	}
	PC13 {
		ec.Pin : {}
		AF2_TIM1_BK : signals.TIM1_BK {
		}
	}
	PC14_OSC32_IN__PC14_ {
		ec.Pin : {}
		AF2_TIM1_BK2 : signals.TIM1_BK2 {
		}
	}
	PC15_OSC32_OUT__PC15_ {
		ec.Pin : {}
		AF0_RCC_OSC32_EN : signals.RCC_OSC32_EN {
		}
		AF1_RCC_OSC_EN : signals.RCC_OSC_EN {
		}
	}
	PC6 {
		ec.Pin : {}
		AF2_TIM2_CH3 : signals.TIM2_CH3 {
		}
		AF1_TIM3_CH1 : signals.TIM3_CH1 {
		}
	}
	PC7 {
		ec.Pin : {}
		AF2_TIM2_CH4 : signals.TIM2_CH4 {
		}
		AF1_TIM3_CH2 : signals.TIM3_CH2 {
		}
	}
	PD0 {
		ec.Pin : {}
		AF0_EVENTOUT : signals.EVENTOUT {
		}
		AF1_SPI2_NSS : signals.SPI2_NSS {
		}
		AF2_TIM16_CH1 : signals.TIM16_CH1 {
		}
	}
	PD1 {
		ec.Pin : {}
		AF0_EVENTOUT : signals.EVENTOUT {
		}
		AF1_SPI2_SCK : signals.SPI2_SCK {
		}
		AF2_TIM17_CH1 : signals.TIM17_CH1 {
		}
	}
	PD2 {
		ec.Pin : {}
		AF2_TIM1_CH1N : signals.TIM1_CH1N {
		}
		AF1_TIM3_ETR : signals.TIM3_ETR {
		}
	}
	PD3 {
		ec.Pin : {}
		AF1_SPI2_MISO : signals.SPI2_MISO {
		}
		AF2_TIM1_CH2N : signals.TIM1_CH2N {
		}
		AF0_USART2_CTS : signals.USART2_CTS {
		}
		AF0_USART2_NSS : signals.USART2_NSS {
		}
	}
	PF0_OSC_IN__PF0_ {
		ec.Pin : {}
		AF2_TIM14_CH1 : signals.TIM14_CH1 {
		}
	}
	PF1_OSC_OUT__PF1_ {
		ec.Pin : {}
		AF0_RCC_OSC_EN : signals.RCC_OSC_EN {
		}
	}
	PF2___NRST {
		ec.Pin : {}
		AF0_RCC_MCO : signals.RCC_MCO {
		}
	}
	PI8 {
		ec.Pin : {}
	}
}
